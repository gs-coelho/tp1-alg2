<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pt-br" xml:lang="pt-br"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.36">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Trabalho Prático 1 - Manipulação de Sequências</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="relatorio_files/libs/clipboard/clipboard.min.js"></script>
<script src="relatorio_files/libs/quarto-html/quarto.js"></script>
<script src="relatorio_files/libs/quarto-html/popper.min.js"></script>
<script src="relatorio_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="relatorio_files/libs/quarto-html/anchor.min.js"></script>
<link href="relatorio_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="relatorio_files/libs/quarto-html/quarto-syntax-highlighting-722b7ecd703fa194e825a0d619ad685e.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="relatorio_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="relatorio_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="relatorio_files/libs/bootstrap/bootstrap-8f12aea710bb83210117cbf50285d15f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Índice</h2>
   
  <ul>
  <li><a href="#introdução" id="toc-introdução" class="nav-link active" data-scroll-target="#introdução">Introdução</a></li>
  <li><a href="#implementação" id="toc-implementação" class="nav-link" data-scroll-target="#implementação">Implementação</a>
  <ul class="collapse">
  <li><a href="#encoderdecoder" id="toc-encoderdecoder" class="nav-link" data-scroll-target="#encoderdecoder">Encoder/Decoder</a></li>
  <li><a href="#dicionário" id="toc-dicionário" class="nav-link" data-scroll-target="#dicionário">Dicionário</a></li>
  </ul></li>
  <li><a href="#análise" id="toc-análise" class="nav-link" data-scroll-target="#análise">Análise</a></li>
  <li><a href="#conclusão" id="toc-conclusão" class="nav-link" data-scroll-target="#conclusão">Conclusão</a></li>
  </ul>
</nav>
</div>
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Trabalho Prático 1 - Manipulação de Sequências</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Código</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Mostrar o código</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Esconder o código</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">Ver o código fonte</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Autores</div>
    <div class="quarto-title-meta-contents">
             <p>Gabriel Coelho dos Santos </p>
             <p>Victor Gabriel Moura Oliveira </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="introdução" class="level2">
<h2 class="anchored" data-anchor-id="introdução">Introdução</h2>
<p>O objetivo deste trabalho é implementar o algoritmo LZW (Lempel-Ziv-Welch) de compressão de arquivos. O método se baseia na substituição de strings que se repetem no texto por códigos, e para isso, faz muitas consultas a um dicionário. Para a implementação desse dicionário, uma árvore de prefixos foi utilizada, em especial uma trie compacta que se baseia nos códigos binários das chaves a serem armazenadas.</p>
<p>Este relatório aborda primeiro a implementação do algoritmo em si, dando uma explicação do código e de como ele se deu. Em seguida, há uma seção de análise, onde testes com diferentes entradas são feitos a fim de observar como o programa se comporta nesses diferentes casos, utilizando métricas geradas durante a execução para quantificar as diferenças.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Nota
</div>
</div>
<div class="callout-body-container callout-body">
<p>Para executar o programa, é preciso instalar as dependências com o comando abaixo:</p>
<pre class="{bash}"><code>pip install -r requirements.txt</code></pre>
<p>O comando abaixo mostrará as flags necessárias para executar o programa:</p>
<pre class="{bash}"><code>python main.py -h  # Windows
python3 main.py -h # Linux</code></pre>
</div>
</div>
</section>
<section id="implementação" class="level2">
<h2 class="anchored" data-anchor-id="implementação">Implementação</h2>
<p>Haviam duas opções de linguagem de programação para o trabalho: C/C++ e Python. O Python foi escolhido devido à sua facilidade de escrita e de compreensão: enquanto o C++ permite um maior controle sobre a alocação de memória e outros detalhes de mais baixo nível, o Python tem funcionalidades como um coletor de lixo que permitem um foco maior na lógica do programa em si, e os detalhes são gerenciados pela própria linguagem.</p>
<p>O código do programa pode ser dividido em duas partes principais, que são abordadas mais à frente com mais detalhes:</p>
<ol type="1">
<li><p>Encoder/Decoder<br>
Essa é a parte responsável pela implementação do algoritmo LZW em si, assim como pelo gerenciamento, leitura e escrita dos arquivos utilizados, traduzindo-os do binário para as strings e vice-versa. Existem duas versões deste código - a versão com códigos de tamanho fixo e a versão com códigos de tamanho variável, que serão tratados separadamente.</p></li>
<li><p>Dicionário<br>
Essa é a parte onde o conteúdo visto em sala é utilizado, implementando uma trie compacta para armazenar as strings e os códigos utilizados no algoritmo LZW.</p></li>
</ol>
<section id="encoderdecoder" class="level3">
<h3 class="anchored" data-anchor-id="encoderdecoder">Encoder/Decoder</h3>
<section id="encoder-com-código-de-tamanho-fixo" class="level4">
<h4 class="anchored" data-anchor-id="encoder-com-código-de-tamanho-fixo">1. Encoder com código de tamanho fixo</h4>
<p>Esta implementação usa códigos com tamanho predinido por parâmetro (default = 12). Quando o limite de códigos possíveis com n bits é atingido (2^n), não são mais criados códigos e apenas aqueles previamente inseridos são utilizados.</p>
<section id="encode" class="level5">
<h5 class="anchored" data-anchor-id="encode"><code>encode</code></h5>
<p>Realiza a codificação dos bits de input em codigos com tamanho de string fixo. Cria uma trie com chaves que representam sequencias de bits e valores que representam os códigos (sequenciais).</p>
<section id="funcionamento" class="level6">
<h6 class="anchored" data-anchor-id="funcionamento">Funcionamento:</h6>
<p>Dado que um dicionario com os dois simbolos do alfabeto(0 e 1) já foi construido. Em seguida, o algoritmo consome símbolos do arquivo de entrada um-a-um. Ao ler um novo símbolo x, o algoritmo concatena x a uma string I, lida anteriormente, e verifica se a string Ix já foi armazenada no dicionário. Caso ela já tenha sido armazenada, o algoritmo atualiza a string I com a nova string Ix, e repete o processo. Caso a string Ix não tenha sido armazenada ainda, o algoritmo adiciona o código referente a I na string de codificação.Caso ainda houverem codigos disponíveis, insere a string Ix associada a um novo código (sequencial) no dicionário, atualiza I com x. Repete o processo até que não haja mais símbolos de entrada.</p>
<div id="a3392740" class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> encode(<span class="va">self</span>):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>        encoding <span class="op">=</span> <span class="st">""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        I <span class="op">=</span> <span class="st">""</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        max_code <span class="op">=</span> <span class="bu">pow</span>(<span class="dv">2</span>,<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        count_compressions <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        start_time <span class="op">=</span> time.time()</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> idx,i <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.__input):</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(<span class="va">self</span>.__stats <span class="op">!=</span> <span class="va">None</span> <span class="kw">and</span> idx <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> idx <span class="op">%</span> <span class="dv">80</span> <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__stats[<span class="st">"compression_rates"</span>].append(count_compressions<span class="op">/</span><span class="dv">80</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>                count_compressions <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.__trie.search(I<span class="op">+</span>i) <span class="op">!=</span> <span class="va">None</span>:</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                I <span class="op">=</span> I <span class="op">+</span> i</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                count_compressions <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="va">self</span>.__codes_count <span class="op">&lt;</span> max_code: <span class="co"># ainda nao estourei o numero de codigos</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__trie.insert(I<span class="op">+</span>i,<span class="va">self</span>.__codes_count)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__codes_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>                code <span class="op">=</span> <span class="va">self</span>.__trie.search(I)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>                code_in_binary <span class="op">=</span> <span class="bu">bin</span>(code)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>                code_in_binary <span class="op">=</span> code_in_binary[<span class="dv">2</span>:]</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>                code_in_binary <span class="op">=</span> code_in_binary.zfill(<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>                encoding<span class="op">+=</span>code_in_binary</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>                I <span class="op">=</span> i</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> I <span class="op">!=</span> <span class="st">""</span>:</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>            code_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__trie.search(I))[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>            encoding<span class="op">+=</span>code_in_binary</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        end_time <span class="op">=</span> time.time()</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"time"</span>] <span class="op">=</span> end_time <span class="op">-</span> start_time</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"dict_size"</span>] <span class="op">=</span> <span class="va">self</span>.__codes_count</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"encoded_size"</span>] <span class="op">=</span> <span class="bu">len</span>(encoding)</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> encoding, <span class="va">self</span>.__stats</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="decode" class="level5">
<h5 class="anchored" data-anchor-id="decode"><code>decode</code></h5>
<p>Realiza a decodificação. Cria uma árvore trie que busca copiar a árvore da codificação, porém nesse caso a árvore mapeia de código para sequencia original de bits.</p>
<section id="funcionamento-1" class="level6">
<h6 class="anchored" data-anchor-id="funcionamento-1">Funcionamento:</h6>
<p>Considerando que o dicionário com os dois símbolos já foi construído. O algoritmo então consome códigos da string de entrada (codificação) em blocos do tamanho definido para os códigos. Ao ler um código, o algoritmo verifica se esse já foi inserido no dicionário. Caso tenha sido, o primeiro símbolo dessa string é concatenado a string anterior, o resultado é adicionado ao dicionário caso já não esteja (foi utilizado um dicionário auxiliar para verificar isso), e impresso na saída. Finalmente, a string anterior é atualizada com a string recuperado pelo código e o processo se repete. Caso o código não esteja no dicionário, a string é concatenada ao seu primeiro símbolo, o resultado é adicionado ao dicionário e concatenado na saída.</p>
<div id="2c488c88" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> decode(<span class="va">self</span>):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>        decoding <span class="op">=</span> <span class="st">""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        previous_str <span class="op">=</span> <span class="st">""</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        it <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        decompressing_acumulator <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        start_time <span class="op">=</span> time.time()</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        insertions <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> idx <span class="op">&lt;</span> <span class="bu">len</span>(<span class="va">self</span>.__encoding):</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            <span class="co"># used to calculate the decompressing rate </span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(<span class="va">self</span>.__stats <span class="op">!=</span> <span class="va">None</span> <span class="kw">and</span> it <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> it <span class="op">%</span> <span class="dv">50</span> <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__stats[<span class="st">"decompression_rates"</span>].append(decompressing_acumulator<span class="op">/</span><span class="dv">50</span>)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>                decompressing_acumulator <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            actual_code <span class="op">=</span> <span class="va">self</span>.__encoding[idx : idx<span class="op">+</span><span class="va">self</span>.__code_size]</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> idx <span class="op">==</span> <span class="dv">0</span>: <span class="co"># trata especialmente o primeiro codigo</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>                previous_str <span class="op">=</span> <span class="va">self</span>.__table.search(actual_code)</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>                idx <span class="op">+=</span> <span class="va">self</span>.__code_size</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            insertions <span class="op">+=</span> <span class="dv">2</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>            <span class="co"># busca o codigo no dicionario</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>            actual_str <span class="op">=</span> <span class="va">self</span>.__table.search(actual_code) </span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (actual_str <span class="op">!=</span> <span class="va">None</span>):<span class="co"># codigo na tabela</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="va">self</span>.__inserted_strs.search(previous_str <span class="op">+</span> actual_str[<span class="dv">0</span>]) <span class="op">==</span> <span class="va">None</span>:</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>                    code_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__code_count)[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__code_size)</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__table.insert(code_in_binary, previous_str <span class="op">+</span> actual_str[<span class="dv">0</span>])</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># dicionario auxiliar que possui como chave as sequencias inseridas</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__inserted_strs.insert(previous_str <span class="op">+</span> actual_str[<span class="dv">0</span>],<span class="dv">0</span>)</span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__code_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>                decoding <span class="op">+=</span> previous_str</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>                decompressing_acumulator <span class="op">+=</span> <span class="bu">len</span>(previous_str)</span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>                previous_str <span class="op">=</span> actual_str</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>                code_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__code_count)[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__code_size)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__table.insert(code_in_binary,previous_str <span class="op">+</span> previous_str[<span class="dv">0</span>])</span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__inserted_strs.insert(previous_str <span class="op">+</span> previous_str[<span class="dv">0</span>],<span class="dv">0</span>)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__code_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>                decoding <span class="op">+=</span> previous_str</span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>                decompressing_acumulator <span class="op">+=</span> <span class="bu">len</span>(previous_str)</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>                previous_str <span class="op">=</span> previous_str <span class="op">+</span> previous_str[<span class="dv">0</span>]</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">+=</span> <span class="va">self</span>.__code_size</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>            it <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>        end_time <span class="op">=</span> time.time()</span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"time"</span>] <span class="op">=</span> end_time <span class="op">-</span> start_time</span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"dict_size"</span>] <span class="op">=</span> insertions                            </span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>        decoding <span class="op">+=</span> previous_str    </span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> decoding, <span class="va">self</span>.__stats</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
</section>
<section id="encoder-com-código-de-tamanho-variável" class="level4">
<h4 class="anchored" data-anchor-id="encoder-com-código-de-tamanho-variável">2. Encoder com código de tamanho variável</h4>
<p>Esta implementação usa códigos com tamanho inicial definido por parâmetro (default = 12) e crescente conforme a necessidade por novos códigos. Quando o limite de códigos máximo com n bits é atingido (2^n), não são mais criados códigos e apenas aqueles previamente inseridos são utilizados.</p>
<section id="encode-1" class="level5">
<h5 class="anchored" data-anchor-id="encode-1"><code>encode</code></h5>
<p>Realiza a codificação de forma semelhar à implementação fixa. No entanto, separa os códigos formados por apenas 1’s para serem flags indicadoras da mudança de tamanho dos códigos.</p>
<div id="30f68366" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> encode(<span class="va">self</span>):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>        encoding <span class="op">=</span> <span class="st">""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        I <span class="op">=</span> <span class="st">""</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        count_compressions <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        start_time <span class="op">=</span> time.time()</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> idx, i <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.__input):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(<span class="va">self</span>.__stats <span class="op">!=</span> <span class="va">None</span> <span class="kw">and</span> idx <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> idx <span class="op">%</span> <span class="dv">80</span> <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__stats[<span class="st">"compression_rates"</span>].append(count_compressions<span class="op">/</span><span class="dv">80</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                count_compressions <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            max_code <span class="op">=</span> <span class="bu">pow</span>(<span class="dv">2</span>,<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.__trie.search(I<span class="op">+</span>i) <span class="op">!=</span> <span class="va">None</span>:</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>                I <span class="op">=</span> I <span class="op">+</span> i</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                count_compressions <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>                estourou <span class="op">=</span> <span class="va">False</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="va">self</span>.__codes_count <span class="op">==</span> max_code<span class="op">-</span><span class="dv">1</span>: <span class="co"># estourei o numero de codigos</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>                    estourou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>                    Icode_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__trie.search(I))[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>                    encoding<span class="op">+=</span>Icode_in_binary</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>                    ones <span class="op">=</span> <span class="bu">bin</span>(<span class="bu">pow</span>(<span class="dv">2</span>,<span class="va">self</span>.__codes_bit_size) <span class="op">-</span> <span class="dv">1</span>)[<span class="dv">2</span>:]</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>                    encoding <span class="op">+=</span> ones</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__codes_bit_size <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__codes_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__trie.insert(I<span class="op">+</span>i,<span class="va">self</span>.__codes_count)</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__codes_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> estourou: <span class="co"># caso nao tenha estourado nessa iteracao</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>                    code <span class="op">=</span> <span class="va">self</span>.__trie.search(I)</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>                    code_in_binary <span class="op">=</span> <span class="bu">bin</span>(code)</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>                    code_in_binary <span class="op">=</span> code_in_binary[<span class="dv">2</span>:]</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>                    code_in_binary <span class="op">=</span> code_in_binary.zfill(<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>                    encoding<span class="op">+=</span>code_in_binary</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>                I <span class="op">=</span> i</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> I <span class="op">!=</span> <span class="st">""</span>:</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>            code_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__trie.search(I))[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>            encoding<span class="op">+=</span>code_in_binary</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>        end_time <span class="op">=</span> time.time()</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"time"</span>] <span class="op">=</span> end_time <span class="op">-</span> start_time</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"dict_size"</span>] <span class="op">=</span> <span class="va">self</span>.__codes_count</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"encoded_size"</span>] <span class="op">=</span> <span class="bu">len</span>(encoding)</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> encoding, <span class="va">self</span>.__stats</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="decode-1" class="level5">
<h5 class="anchored" data-anchor-id="decode-1"><code>decode</code></h5>
<p>Implementação semelhante à implementação fixa. No entanto, precisa tratar o caso de que o código passado é uma flag para a mudança de tamanho dos códigos.</p>
<div id="b9b43dfa" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> decode(<span class="va">self</span>):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>        decoding <span class="op">=</span> <span class="st">""</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        previous_str <span class="op">=</span> <span class="st">""</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        it <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        decompressing_acumulator <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        start_time <span class="op">=</span> time.time()</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        insertions <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> idx <span class="op">&lt;</span> <span class="bu">len</span>(<span class="va">self</span>.__encoding):</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            <span class="co"># decompression rate computation</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(<span class="va">self</span>.__stats <span class="op">!=</span> <span class="va">None</span> <span class="kw">and</span> it <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> it <span class="op">%</span> <span class="dv">50</span> <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__stats[<span class="st">"decompression_rates"</span>].append(decompressing_acumulator<span class="op">/</span><span class="dv">50</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>                decompressing_acumulator <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>            actual_code <span class="op">=</span> <span class="va">self</span>.__encoding[idx : idx<span class="op">+</span><span class="va">self</span>.__code_size]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> idx <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>                previous_str <span class="op">=</span> <span class="va">self</span>.__table.search(actual_code)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>                idx <span class="op">+=</span> <span class="va">self</span>.__code_size</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">#flag atual</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>            flag <span class="op">=</span> <span class="bu">bin</span>(<span class="bu">pow</span>(<span class="dv">2</span>,<span class="va">self</span>.__code_size) <span class="op">-</span><span class="dv">1</span>)[<span class="dv">2</span>:]</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> actual_code <span class="op">==</span> flag:</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__table.reroot()</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__code_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>                idx <span class="op">+=</span> <span class="va">self</span>.__code_size</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__code_size <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>            insertions <span class="op">+=</span> <span class="dv">2</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>            actual_str <span class="op">=</span> <span class="va">self</span>.__table.search(actual_code) </span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (actual_str <span class="op">!=</span> <span class="va">None</span>):<span class="co"># codigo na tabela</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="va">self</span>.__inserted_strs.search(previous_str <span class="op">+</span> actual_str[<span class="dv">0</span>]) <span class="op">==</span> <span class="va">None</span>:</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>                    code_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__code_count)[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__code_size)</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__table.insert(code_in_binary, previous_str <span class="op">+</span> actual_str[<span class="dv">0</span>])</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__inserted_strs.insert(previous_str <span class="op">+</span> actual_str[<span class="dv">0</span>],<span class="dv">0</span>)</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__code_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>                decoding <span class="op">+=</span> previous_str</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>                decompressing_acumulator <span class="op">+=</span> <span class="bu">len</span>(previous_str)</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>                previous_str <span class="op">=</span> actual_str</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>                code_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__code_count)[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__code_size)</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__table.insert(code_in_binary,previous_str <span class="op">+</span> previous_str[<span class="dv">0</span>])</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__inserted_strs.insert(previous_str <span class="op">+</span> previous_str[<span class="dv">0</span>],<span class="dv">0</span>)</span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__code_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>                decoding <span class="op">+=</span> previous_str</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>                decompressing_acumulator <span class="op">+=</span> <span class="bu">len</span>(previous_str)</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>                previous_str <span class="op">=</span> previous_str <span class="op">+</span> previous_str[<span class="dv">0</span>]</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">+=</span> <span class="va">self</span>.__code_size</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>            it <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>        end_time <span class="op">=</span> time.time()</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"time"</span>] <span class="op">=</span> end_time <span class="op">-</span> start_time</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"dict_size"</span>] <span class="op">=</span> insertions                   </span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>        decoding <span class="op">+=</span> previous_str    </span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> decoding, <span class="va">self</span>.__stats</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
</section>
<section id="dicionário" class="level3">
<h3 class="anchored" data-anchor-id="dicionário">Dicionário</h3>
<p>Para a implementação do dicionário, utilizamos uma árvore de prefixos, em especial uma árvore trie compacta. Nesta árvore, as chaves de busca e inserção são os valores binários dos códigos ou do conteúdo dos arquivos, transformados em strings de 0s e 1s. Isso aumenta o custo em memória do algoritmo, que utiliza um caractere para cada bit da chave, mas facilita a implementação dos algoritmos que precisam manipular e comparar essas strings para verificar quando os prefixos casam.</p>
<p>A trie implementada aqui trata a raiz como um nó cabeça, onde o prefixo armazenado é a string vazia. Contanto que os devidos cuidados sejam tomados ao manipular este nó, isso facilita a implementação dos métodos, visto que todos eles podem iniciar a partir dela seguramente, sabendo que a string vazia é um prefixo de todas as strings.</p>
<p>A seguir, temos uma explicação dos métodos implementados na classe do Dicionário, incluindo os métodos auxiliares.</p>
<section id="prefix_match" class="level4">
<h4 class="anchored" data-anchor-id="prefix_match"><code>_prefix_match</code></h4>
<p>Um método auxiliar <code>_prefix_match</code> foi implementado para fazer as comparações entre diferentes strings: ele verifica qual é o maior prefixo em comum entre as duas strings passadas. Isso é útil na inserção, por exemplo, onde o método é utilizado para descobrir a partir de que ponto a chave a ser inserida diverge da chave já armazenada, e que porção destas deve ser passada para um nó filho.</p>
<div id="97557f39" class="cell" data-execution_count="5">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _prefix_match(<span class="va">self</span>, s1: <span class="bu">str</span>, s2: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Returns the length of the largest common prefix of s1 and s2"""</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c1, c2 <span class="kw">in</span> <span class="bu">zip</span>(s1, s2):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> c1 <span class="op">!=</span> c2:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> i</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="search" class="level4">
<h4 class="anchored" data-anchor-id="search"><code>search</code></h4>
<p>Este é o método que performa a busca na trie compacta. A partir da raiz, ele escolhe um dos filhos para buscar baseado no primeiro dígito da parte ainda não casada da chave que está sendo buscada. Ele então verifica se a chave casa todo o prefixo armazenado naquele nó, acumula o prefixo casado, e em seguida, repete o processo a partir deste nó filho, e assim sucessivamente até que a chave seja encontrada, a profundidade da trie seja exaurida, ou alguma divergência ocorra. Nesses últimos dois casos, a chave não está na trie.</p>
<div id="046f7ec5" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> search(<span class="va">self</span>, bit_str: <span class="bu">str</span>):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Searches a bit string in the dictionary and returns the value on success, or None if not found."""</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    node <span class="op">=</span> <span class="va">self</span>.root</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    length <span class="op">=</span> <span class="bu">len</span>(bit_str)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> length:</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        bit <span class="op">=</span> <span class="bu">int</span>(bit_str[i])</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Search reached a leaf without fully matching bit_str</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node.children[bit] <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Child diverges from bit_str -&gt; there can't be a leaf that matches bit_str fully</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        child <span class="op">=</span> node.children[bit]</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> bit_str.startswith(child.prefix, i):</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> child</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="bu">len</span>(child.prefix)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> node.value</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="insert" class="level4">
<h4 class="anchored" data-anchor-id="insert"><code>insert</code></h4>
<p>Este método é responsável por inserir na trie novos nós com uma chave e um valor, e atualizar o valor já presente caso a chave sendo inserida seja uma chave já inserida anteriormente.</p>
<p>A ideia é percorrer a trie, de forma similar ao método de busca, buscando o nó onde a chave deveria estar, se estivesse presente. Se ela estiver de fato presente na trie, atualiza o valor já armazenado. Se houver divergência em algum nó e o prefixo armazenado nele não casar completamente com a chave sendo inserida, um novo filho é criado neste nó com a parte da nova chave que não foi casada, remanejando a trie para que ela se mantenha em um estado válido.</p>
<div id="db86f341" class="cell" data-execution_count="7">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> insert(<span class="va">self</span>, bit_str: <span class="bu">str</span>, value: <span class="bu">any</span>):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Inserts a new value, with bit_str as the key, and updates the value if it already exists.</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns False if the key was updated, or True if it was inserted fresh.</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    node <span class="op">=</span> <span class="va">self</span>.root</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    length <span class="op">=</span> <span class="bu">len</span>(bit_str)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> length:</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        bit <span class="op">=</span> <span class="bu">int</span>(bit_str[i])</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node.children[bit] <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Creates a new node with the rest of bit_str as the key</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            new_node <span class="op">=</span> Node(bit_str[i:], value)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            node.children[bit] <span class="op">=</span> new_node</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        child <span class="op">=</span> node.children[bit]</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        common_prefix_length <span class="op">=</span> <span class="va">self</span>._prefix_match(child.prefix, bit_str[i:])</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> common_prefix_length <span class="op">==</span> <span class="bu">len</span>(child.prefix):</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>            <span class="co"># The whole prefix matched -&gt; move to the apropriate child</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> child</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> common_prefix_length</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>            <span class="co"># The strings diverge at this node -&gt; separate into 2 subtrees</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>            new_prefix <span class="op">=</span> child.prefix[:common_prefix_length]</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>            existing_suffix <span class="op">=</span> child.prefix[common_prefix_length:]</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>            new_suffix <span class="op">=</span> bit_str[i <span class="op">+</span> common_prefix_length:]</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create new intermediary node for common prefix</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>            new_node <span class="op">=</span> Node(new_prefix)</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Transform old node and add it as child to the new node</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>            child.prefix <span class="op">=</span> existing_suffix</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>            existing_suffix_bit <span class="op">=</span> <span class="bu">int</span>(existing_suffix[<span class="dv">0</span>])</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>            new_node.children[existing_suffix_bit] <span class="op">=</span> child</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Adds a leaf to the new node if there is a suffix left in bit_str</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(new_suffix) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>                leaf_node <span class="op">=</span> Node(new_suffix, value)</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>                leaf_node_bit <span class="op">=</span> <span class="bu">int</span>(new_suffix[<span class="dv">0</span>])</span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>                new_node.children[leaf_node_bit] <span class="op">=</span> leaf_node</span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>                new_node.value <span class="op">=</span> value</span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Adds new intermediary node to the tree </span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a>            node.children[bit] <span class="op">=</span> new_node</span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The key already existed in the trie -&gt; update its value</span></span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>    node.value <span class="op">=</span> value</span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="remove" class="level4">
<h4 class="anchored" data-anchor-id="remove"><code>remove</code></h4>
<p>Este é o método responsável pela remoção de elementos da trie, a partir de uma chave dada, retornando para o programa se a remoção teve sucesso ou não. Ele utiliza um método interno auxiliar <code>_remove</code> que, recursivamente, percorre a árvore, aumentando o nível de profundidade até encontrar o nó que precisa ser apagado, caso exista. Em seguida, ele propaga para cima se o nó deve ser apagado ou não, de forma que, caso um nó possa ser compactado ou fique vazio, seu nó pai é avisado e o processo de compactação é feito. Esse efeito de propagação continua até atingir um nó que não precise ser apagado, indicando que, dali para cima, a trie não precisa ser modificada.</p>
<p>A recursão é necessária aqui porque os nós da árvore de prefixos não têm um ponteiro para o pai, então esse mecanismo é utilizado para que seja possível viajar na árvore no sentido inverso. Esse método recursivo é o que garante que a trie compacta permaneça compacta ao remover um elemento, e sem isso a árvore poderia ser deixada num estado inválido.</p>
<div id="f1647a5e" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> remove(<span class="va">self</span>, bit_str: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Removes key from dictionary, returning True on success and False on failure</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">    (ex. if the key isn't in the dictionary)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _remove(node: Node, bit_str: <span class="bu">str</span>, depth: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">tuple</span>[<span class="bu">bool</span>, <span class="bu">bool</span>]:</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co">        Recursive method for removing key.</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns a tuple (bool, bool) indicating if the removal was successful</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co">        and if the child can be removed, respectively.</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Node doesn't exist</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="va">False</span>, <span class="va">False</span>)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># When the corresponding node is found</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> depth <span class="op">==</span> <span class="bu">len</span>(bit_str):</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node.value <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>                node.value <span class="op">=</span> <span class="va">None</span>  <span class="co"># Delete value</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (<span class="va">True</span>, node.is_leaf()) <span class="co"># Node is leaf -&gt; can be deleted</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="va">True</span>, <span class="va">False</span>)</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>        bit <span class="op">=</span> <span class="bu">int</span>(bit_str[depth])</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node.children[bit] <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="va">False</span>, <span class="va">False</span>)  <span class="co"># String is not in trie</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>        child <span class="op">=</span> node.children[bit]</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>        common_prefix_length <span class="op">=</span> <span class="va">self</span>._prefix_match(child.prefix, bit_str[depth:])</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>        <span class="co"># bit_str diverges from the prefix, so it can't be on the trie</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> common_prefix_length <span class="op">&lt;</span> <span class="bu">len</span>(child.prefix):</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="va">False</span>, <span class="va">False</span>)</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>        success, can_remove_child <span class="op">=</span> _remove(child, bit_str, depth <span class="op">+</span> common_prefix_length)</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> can_remove_child:</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>            node.children[bit] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>            <span class="co"># If node now became an empty leaf, it can be removed too</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node.is_leaf() <span class="kw">and</span> node.value <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (success, <span class="va">True</span>)</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Node is not root, is empty and stil has another child that can be compacted into it</span></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node.prefix <span class="op">!=</span> <span class="st">''</span> <span class="kw">and</span> node.value <span class="kw">is</span> <span class="va">None</span> <span class="kw">and</span> node.children.count(<span class="va">None</span>) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>                remaining_child <span class="op">=</span> node.children[<span class="dv">1</span> <span class="op">-</span> bit]</span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>                node.prefix <span class="op">+=</span> remaining_child.prefix</span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a>                node.value <span class="op">=</span> remaining_child.value</span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>                node.children <span class="op">=</span> remaining_child.children</span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (success, <span class="va">False</span>)</span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Child couldn't be removed. Assuming tree was valid before, it should remain valid.</span></span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (success, <span class="va">False</span>)</span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Starts recursive removal from root</span></span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true" tabindex="-1"></a>    success, _ <span class="op">=</span> _remove(<span class="va">self</span>.root, bit_str, <span class="dv">0</span>)</span>
<span id="cb10-58"><a href="#cb10-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> success</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="reroot" class="level4">
<h4 class="anchored" data-anchor-id="reroot"><code>reroot</code></h4>
<p>Essa função não implementa uma funcionalidade padrão de um dicionário, mas sim uma funcionalidade útil para o algoritmo LZW. O objetivo desta função é acrescentar um prefixo 0 a todas as chaves já armazenadas na árvore. Isto é útil ao implementar o LZW com tamanho de código variável, pois, quando os códigos precisam aumentar de tamanho, essa função aumenta o tamanho de todos os códigos antigos para que sejam compatíveis com os novos códigos.</p>
<p>Para atingir esse objetivo, a função cria uma nova raiz, transforma a antiga raiz para que ela possua um prefixo de 0, e define esse nó transformado como filho da nova raiz, de forma que toda a trie anterior se torna uma subárvore com prefixo 0. Um cuidado é tomado caso a raiz tenha apenas um filho, para que a propriedade de compactação da trie seja mantida.</p>
<div id="6f49a2ee" class="cell" data-execution_count="9">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reroot(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Creates a new root for the underlying trie. If the trie is not empty,</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co">    places the old root as child to the new root, with prefix 0 and no value.</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns true if rerooting took place, and false if it didn't.</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    num_children <span class="op">=</span> <span class="dv">2</span> <span class="op">-</span> <span class="va">self</span>.root.children.count(<span class="va">None</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># No values to be rerooted</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> num_children <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Root has a single child, that would be fused into the new 0 node, so we</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># can just modify the current only child</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="va">self</span>.root.children.count(<span class="va">None</span>) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        bit <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.root.children.index(<span class="va">None</span>)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        child <span class="op">=</span> <span class="va">self</span>.root.children[bit]</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        child.prefix <span class="op">=</span> <span class="st">'0'</span> <span class="op">+</span> child.prefix</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.root.children <span class="op">=</span> [child, <span class="va">None</span>]</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Root has two children, transform it into the new 0 node and attach to new root</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    old_root <span class="op">=</span> <span class="va">self</span>.root</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    new_root <span class="op">=</span> Node(<span class="st">''</span>, <span class="va">None</span>)</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    old_root.prefix <span class="op">=</span> <span class="st">'0'</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    new_root.children[<span class="dv">0</span>] <span class="op">=</span> old_root</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.root <span class="op">=</span> new_root</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
</section>
<section id="análise" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="análise">Análise</h2>
<p>Para poder analisar o bom funcionamento do programa, foram feitos diversos testes, executando o programa com parâmetros diferentes e formatos de arquivo diferentes. Dessas execuções extraímos diversas métricas, como a taxa de compressão (e de descompressão) do arquivo ao longo da execução do programa, o tempo total de execução e a quantidade de inserções na trie. Utilizaremos essas métricas para caracterizar o programa.</p>
<p>Um cuidado especial tomado foi o de testar o programa com formatos de arquivo descomprimidos, como imagens em formato Bitmap (.bmp) e arquivos de texto puros (.txt). Isso é necessário porque existe um limite para quanto uma informação pode ser comprimida, relacionado à <a href="https://pt.wikipedia.org/wiki/Entropia_da_informa%C3%A7%C3%A3o">entropia da informação definida por Shannon</a>. Por esse motivo, arquivos já comprimidos anteriormente, como imagens .png e documentos .pdf tendem a não reduzir significativamente em tamanho com passagens adicionais por um algoritmo de compressão, o que faz com que esses formatos não sejam ideais para testar o funcionamento&nbsp;do&nbsp;programa.</p>
<p>Nos arquivos de texto, foram feitos com três tamanhos diferentes de arquivo:</p>
<ol type="1">
<li>um arquivo pequeno (6,25KB)</li>
<li>um arquivo médio (22,6KB)</li>
<li>e um arquivo grande (418KB).</li>
</ol>
<p>A primeira métrica a analisar é a taxa de compressão: para encontrar esse valor, marcamos toda vez que um bit é omitido da saída por já estar representado em um código. Esse valor é amostrado a cada 80 iterações do algoritmo. Abaixo temos as taxas de compressão para os três arquivos, com largura fixa:</p>
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>files <span class="op">=</span> [</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/theraven_stats_encoding_fixed.json"</span>,</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/frankesteinCh1-2_stats_encoding_fixed.json"</span>,</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/frankesteinfull_stats_encoding_fixed.json"</span>,</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, <span class="bu">file</span> <span class="kw">in</span> <span class="bu">enumerate</span>(files):</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(sanitize(<span class="bu">file</span>),<span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        stats_encoding <span class="op">=</span> json.load(f)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        plot_list(y <span class="op">=</span> stats_encoding[<span class="st">"compression_rates"</span>],</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>                        y_label <span class="op">=</span> <span class="st">"Taxa de compressão"</span>, x_label <span class="op">=</span> <span class="st">"Iterações (x80)"</span>,</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>                        title<span class="op">=</span><span class="ss">f"Análise da taxa de compressão - Arquivo </span><span class="sc">{</span>i <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="63f52a2c" class="cell column-page quarto-layout-panel" data-layout-ncol="3" data-execution_count="11">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: center;">
<p><img src="relatorio_files/figure-html/cell-12-output-1.png" class="img-fluid" width="597"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: center;">
<p><img src="relatorio_files/figure-html/cell-12-output-2.png" class="img-fluid" width="597"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: center;">
<p><img src="relatorio_files/figure-html/cell-12-output-3.png" class="img-fluid" width="597"></p>
</div>
</div>
</div>
<p>E também com largura variável:</p>
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>files <span class="op">=</span> [</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/theraven_stats_encoding_variable.json"</span>,</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/frankesteinCh1-2_stats_encoding_variable.json"</span>,</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/frankesteinfull_stats_encoding_variable.json"</span>,</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, <span class="bu">file</span> <span class="kw">in</span> <span class="bu">enumerate</span>(files):</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(sanitize(<span class="bu">file</span>),<span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        stats_encoding <span class="op">=</span> json.load(f)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        plot_list(y <span class="op">=</span> stats_encoding[<span class="st">"compression_rates"</span>],</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>                        y_label <span class="op">=</span> <span class="st">"Taxa de compressão"</span>, x_label <span class="op">=</span> <span class="st">"Iterações (x80)"</span>,</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>                        title<span class="op">=</span><span class="ss">f"Análise da taxa de compressão - Arquivo </span><span class="sc">{</span>i <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="a24e0318" class="cell column-page quarto-layout-panel" data-layout-ncol="3" data-execution_count="12">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: center;">
<p><img src="relatorio_files/figure-html/cell-13-output-1.png" class="img-fluid" width="597"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: center;">
<p><img src="relatorio_files/figure-html/cell-13-output-2.png" class="img-fluid" width="597"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: center;">
<p><img src="relatorio_files/figure-html/cell-13-output-3.png" class="img-fluid" width="597"></p>
</div>
</div>
</div>
<p>Podemos perceber que os três arquivos conseguiram atingir uma taxa de compressão semelhante ao final, próximo dos 95%. Isso significa que esse valor provavelmente está próximo do limite, e que o algoritmo está funcionando bem.</p>
<p>Podemos perceber também que os arquivos maiores apresentaram maior variação nos valores amostrados, com os gráficos sendo muito mais erráticos ao redor da curva aparente nos arquivos maiores, enquanto nos arquivos menores o gráfico é mais bem comportado. Outro fator que influencia esse comportamento é o número de iterações/amostras: o arquivo menor levou cerca de 52000 iterações (o valor no eixo X representa 50 iterações por unidade), ao passo que o arquivo maior levou cerca de 3.6M iterações.</p>
<p>Outro ponto importante é o de que a taxa de compressão parece subir um pouco mais lentamente na compressão variável em comparação com a compressão fixa. Isso fica ainda mais evidente ao analisar a taxa de descompressão, que mede quantos bits foram decodificados a cada amostra (medida a cada 50 iterações). Abaixo temos as taxas de descompressão para o arquivos médio:</p>
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>files <span class="op">=</span> [</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/frankesteinCh1-2_stats_decoding_fixed.json"</span>,</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/frankesteinCh1-2_stats_decoding_variable.json"</span>,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>titles <span class="op">=</span> [</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Análise da taxa de descompressão - Largura Fixa"</span>,</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Análise da taxa de descompressão - Largura Variável"</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, <span class="bu">file</span> <span class="kw">in</span> <span class="bu">enumerate</span>(files):</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(sanitize(<span class="bu">file</span>),<span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        stats_decoding <span class="op">=</span> json.load(f)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        plot_list(y <span class="op">=</span> stats_decoding[<span class="st">"decompression_rates"</span>],</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>                        y_label <span class="op">=</span> <span class="st">"Taxa de descompressão"</span>, x_label <span class="op">=</span> <span class="st">"Iterações (x50)"</span>,</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>                        title<span class="op">=</span>titles[i])</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="c535f94e" class="cell column-page quarto-layout-panel" data-layout-ncol="2" data-execution_count="13">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="relatorio_files/figure-html/cell-14-output-1.png" class="img-fluid" width="585"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="relatorio_files/figure-html/cell-14-output-2.png" class="img-fluid" width="585"></p>
</div>
</div>
</div>
<p>Quanto ao número de inserções na trie, em todos os casos a versão com código de largura variável teve um número de inserções maior, já que o código pode “crescer” quando necessário:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>Fixa</th>
<th>Variável</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Arquivo 1</td>
<td>4096</td>
<td>4490</td>
</tr>
<tr class="even">
<td>Arquivo 2</td>
<td>4096</td>
<td>12756</td>
</tr>
<tr class="odd">
<td>Arquivo 3</td>
<td>4096</td>
<td>146788</td>
</tr>
</tbody>
</table>
<p>O mesmo acontece com arquivos de imagem, que abordaremos em seguida.</p>
<p>Nos arquivos de imagem, temos dois exemplos:</p>
<ol type="1">
<li>um gradiente simples, de 400px x 400px (468KB)</li>
<li>uma imagem mais detalhada e fotorrealista, de tamanho 640px x 426px (798KB)</li>
</ol>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="validation_data/realistic_gradient_400x400.bmp" class="img-fluid figure-img"></p>
<figcaption>Um gradiente simples.</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="validation_data/sample_640x426.bmp" class="img-fluid figure-img"></p>
<figcaption>Uma paisagem fotorrealista.</figcaption>
</figure>
</div>
<p>Abaixo temos as taxas de compressão utilizando largura fixa:</p>
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>files <span class="op">=</span> [</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/realistic_gradient_400x400_stats_encoding_fixed.json"</span>,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/sample_640x426_stats_encoding_fixed.json"</span>,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, <span class="bu">file</span> <span class="kw">in</span> <span class="bu">enumerate</span>(files):</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(sanitize(<span class="bu">file</span>),<span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        stats_encoding <span class="op">=</span> json.load(f)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        plot_list(y <span class="op">=</span> stats_encoding[<span class="st">"compression_rates"</span>],</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>                        y_label <span class="op">=</span> <span class="st">"Taxa de compressão"</span>, x_label <span class="op">=</span> <span class="st">"Iterações (x80)"</span>,</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>                        title<span class="op">=</span><span class="ss">f"Análise da taxa de compressão - Arquivo </span><span class="sc">{</span>i <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="01e1f507" class="cell column-page quarto-layout-panel" data-layout-ncol="2" data-execution_count="14">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="relatorio_files/figure-html/cell-15-output-1.png" class="img-fluid" width="614"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="relatorio_files/figure-html/cell-15-output-2.png" class="img-fluid" width="597"></p>
</div>
</div>
</div>
<p>E também com a largura variável:</p>
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>files <span class="op">=</span> [</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/realistic_gradient_400x400_stats_encoding_variable.json"</span>,</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/sample_640x426_stats_encoding_variable.json"</span>,</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, <span class="bu">file</span> <span class="kw">in</span> <span class="bu">enumerate</span>(files):</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(sanitize(<span class="bu">file</span>),<span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        stats_encoding <span class="op">=</span> json.load(f)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        plot_list(y <span class="op">=</span> stats_encoding[<span class="st">"compression_rates"</span>],</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>                        y_label <span class="op">=</span> <span class="st">"Taxa de compressão"</span>, x_label <span class="op">=</span> <span class="st">"Iterações (x80)"</span>,</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>                        title<span class="op">=</span><span class="ss">f"Análise da taxa de compressão - Arquivo </span><span class="sc">{</span>i <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copiar para a área de transferência" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div id="9194b282" class="cell column-page quarto-layout-panel" data-layout-ncol="2" data-execution_count="15">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="relatorio_files/figure-html/cell-16-output-1.png" class="img-fluid" width="614"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="relatorio_files/figure-html/cell-16-output-2.png" class="img-fluid" width="597"></p>
</div>
</div>
</div>
<p>Imediatamente podemos ver que, assim como nos arquivos de texto maiores, a variabilidade da taxa de compressão também é grande. As imagens em formato bitmap tendem a ser grandes por não serem comprimidas, o que explica a variabilidade encontrada. Apesar disso, as curvas nas duas imagens se afinam ao final, chegando mais próximas de convergir a um valor fixo.</p>
<p>Também é possível notar que a taxa de compressão foi menor na imagem realista do que no gradiente, apesar do tamanho. Isso se dá pela natureza do algoritmo LZW, que explora as repetições de padrões no texto para reduzir seu tamanho. Numa imagem mais simples, como um gradiente, há muita repetição, o que faz com que o algoritmo tenha mais oportunidades de compressão, em oposição à imagem fotorrealista, que por conter muitos detalhes diferentes, não tem muitos padrões que se repetem, o que não permite que o algoritmo seja tão eficiente. Sendo assim, podemos generalizar que o algoritmo funciona melhor em imagens com muita repetição de padrões e elementos.</p>
<p>Pode-se perceber também que a compressão com tamanho de código variável chega mais perto do valor final gradualmente e crescendo, enquanto a versão com tamanho fixo chega a um valor máximo mas depois decai, oscilando até chegar no valor final.</p>
</section>
<section id="conclusão" class="level2">
<h2 class="anchored" data-anchor-id="conclusão">Conclusão</h2>
<p>O algoritmo LZW é um algoritmo de compressão baseado em dicionários que explora padrões repetidos no arquivo de entrada para reduzir o tamanho do arquivo final. Ele funciona melhor em arquivos de texto do que imagens, e funciona melhor em arquivos não-comprimidos que possuem muita repetição, como imagens mais simples, por exemplo.</p>
<p>A trie compacta, apesar de ser uma escolha lógica para essa aplicação, não é a melhor escolha em sua forma padrão. Otimizações como a utilização de funções de hash podem fazer com que ela seja mais eficiente para o LZW em particular.</p>
<!-- -->

</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiada");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiada");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Código fonte</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb17" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Trabalho Prático 1 - Manipulação de Sequências"</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="an">authors:</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: "Gabriel Coelho dos Santos"</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: "Victor Gabriel Moura Oliveira"</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="an">toc:</span><span class="co"> true</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="an">number-sections:</span><span class="co"> false</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="an">highlight-style:</span><span class="co"> github</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="an">code-tools:</span><span class="co"> true</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="an">lang:</span><span class="co"> pt-br</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span><span class="co"> </span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: true</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="fu">## Introdução</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>O objetivo deste trabalho é implementar o algoritmo LZW (Lempel-Ziv-Welch) de compressão de arquivos. O método se baseia na substituição de strings que se repetem no texto por códigos, e para isso, faz muitas consultas a um dicionário. Para a implementação desse dicionário, uma árvore de prefixos foi utilizada, em especial uma trie compacta que se baseia nos códigos binários das chaves a serem armazenadas.</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>Este relatório aborda primeiro a implementação do algoritmo em si, dando uma explicação do código e de como ele se deu. Em seguida, há uma seção de análise, onde testes com diferentes entradas são feitos a fim de observar como o programa se comporta nesses diferentes casos, utilizando métricas geradas durante a execução para quantificar as diferenças.</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>Para executar o programa, é preciso instalar as dependências com o comando abaixo:</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a><span class="in">```{bash}</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install <span class="at">-r</span> requirements.txt</span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>O comando abaixo mostrará as flags necessárias para executar o programa:</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a><span class="in">```{bash}</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a><span class="ex">python</span> main.py <span class="at">-h</span>  <span class="co"># Windows</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a><span class="ex">python3</span> main.py <span class="at">-h</span> <span class="co"># Linux</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a><span class="fu">## Implementação</span></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>Haviam duas opções de linguagem de programação para o trabalho: C/C++ e Python. O Python foi escolhido devido à sua facilidade de escrita e de compreensão: enquanto o C++ permite um maior controle sobre a alocação de memória e outros detalhes de mais baixo nível, o Python tem funcionalidades como um coletor de lixo que permitem um foco maior na lógica do programa em si, e os detalhes são gerenciados pela própria linguagem.</span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a>O código do programa pode ser dividido em duas partes principais, que são abordadas mais à frente com mais detalhes:</span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Encoder/Decoder \</span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>Essa é a parte responsável pela implementação do algoritmo LZW em si, assim como pelo gerenciamento, leitura e escrita dos arquivos utilizados, traduzindo-os do binário para as strings e vice-versa. Existem duas versões deste código - a versão com códigos de tamanho fixo e a versão com códigos de tamanho variável, que serão tratados separadamente.</span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Dicionário \</span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>Essa é a parte onde o conteúdo visto em sala é utilizado, implementando uma trie compacta para armazenar as strings e os códigos utilizados no algoritmo LZW.</span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a><span class="fu">### Encoder/Decoder</span></span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-54"><a href="#cb17-54" aria-hidden="true" tabindex="-1"></a><span class="fu">#### 1. Encoder com código de tamanho fixo</span></span>
<span id="cb17-55"><a href="#cb17-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-56"><a href="#cb17-56" aria-hidden="true" tabindex="-1"></a>Esta implementação usa códigos com tamanho predinido por parâmetro (default = 12). Quando o limite de códigos possíveis com n bits é atingido (2^n), não são mais criados códigos e apenas aqueles previamente inseridos são utilizados.</span>
<span id="cb17-57"><a href="#cb17-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-58"><a href="#cb17-58" aria-hidden="true" tabindex="-1"></a><span class="fu">##### `encode`</span></span>
<span id="cb17-59"><a href="#cb17-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-60"><a href="#cb17-60" aria-hidden="true" tabindex="-1"></a>Realiza a codificação dos bits de input em codigos com tamanho de string fixo. Cria uma trie com chaves que representam sequencias de bits e valores que representam os códigos (sequenciais).</span>
<span id="cb17-61"><a href="#cb17-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-62"><a href="#cb17-62" aria-hidden="true" tabindex="-1"></a><span class="fu">###### Funcionamento: </span></span>
<span id="cb17-63"><a href="#cb17-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-64"><a href="#cb17-64" aria-hidden="true" tabindex="-1"></a>Dado que um dicionario com os dois simbolos do alfabeto(0 e 1) já foi construido. Em seguida, o algoritmo consome símbolos do arquivo de entrada um-a-um. Ao ler um novo símbolo x, o algoritmo concatena x a uma string I, lida anteriormente, e verifica se a string Ix já foi armazenada no dicionário. Caso ela já tenha sido armazenada, o algoritmo atualiza a string I com a nova string Ix, e repete o processo. Caso a string Ix não tenha sido armazenada ainda, o algoritmo adiciona o código referente a I na string de codificação.Caso ainda houverem codigos disponíveis, insere a string Ix associada a um novo código (sequencial) no dicionário, atualiza I com x. Repete o processo até que não haja mais símbolos de entrada.</span>
<span id="cb17-65"><a href="#cb17-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-68"><a href="#cb17-68" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-69"><a href="#cb17-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> encode(<span class="va">self</span>):</span>
<span id="cb17-70"><a href="#cb17-70" aria-hidden="true" tabindex="-1"></a>        encoding <span class="op">=</span> <span class="st">""</span></span>
<span id="cb17-71"><a href="#cb17-71" aria-hidden="true" tabindex="-1"></a>        I <span class="op">=</span> <span class="st">""</span></span>
<span id="cb17-72"><a href="#cb17-72" aria-hidden="true" tabindex="-1"></a>        max_code <span class="op">=</span> <span class="bu">pow</span>(<span class="dv">2</span>,<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb17-73"><a href="#cb17-73" aria-hidden="true" tabindex="-1"></a>        count_compressions <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-74"><a href="#cb17-74" aria-hidden="true" tabindex="-1"></a>        start_time <span class="op">=</span> time.time()</span>
<span id="cb17-75"><a href="#cb17-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> idx,i <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.__input):</span>
<span id="cb17-76"><a href="#cb17-76" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(<span class="va">self</span>.__stats <span class="op">!=</span> <span class="va">None</span> <span class="kw">and</span> idx <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> idx <span class="op">%</span> <span class="dv">80</span> <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb17-77"><a href="#cb17-77" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__stats[<span class="st">"compression_rates"</span>].append(count_compressions<span class="op">/</span><span class="dv">80</span>)</span>
<span id="cb17-78"><a href="#cb17-78" aria-hidden="true" tabindex="-1"></a>                count_compressions <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-79"><a href="#cb17-79" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.__trie.search(I<span class="op">+</span>i) <span class="op">!=</span> <span class="va">None</span>:</span>
<span id="cb17-80"><a href="#cb17-80" aria-hidden="true" tabindex="-1"></a>                I <span class="op">=</span> I <span class="op">+</span> i</span>
<span id="cb17-81"><a href="#cb17-81" aria-hidden="true" tabindex="-1"></a>                count_compressions <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-82"><a href="#cb17-82" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb17-83"><a href="#cb17-83" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="va">self</span>.__codes_count <span class="op">&lt;</span> max_code: <span class="co"># ainda nao estourei o numero de codigos</span></span>
<span id="cb17-84"><a href="#cb17-84" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__trie.insert(I<span class="op">+</span>i,<span class="va">self</span>.__codes_count)</span>
<span id="cb17-85"><a href="#cb17-85" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__codes_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-86"><a href="#cb17-86" aria-hidden="true" tabindex="-1"></a>                    </span>
<span id="cb17-87"><a href="#cb17-87" aria-hidden="true" tabindex="-1"></a>                code <span class="op">=</span> <span class="va">self</span>.__trie.search(I)</span>
<span id="cb17-88"><a href="#cb17-88" aria-hidden="true" tabindex="-1"></a>                code_in_binary <span class="op">=</span> <span class="bu">bin</span>(code)</span>
<span id="cb17-89"><a href="#cb17-89" aria-hidden="true" tabindex="-1"></a>                code_in_binary <span class="op">=</span> code_in_binary[<span class="dv">2</span>:]</span>
<span id="cb17-90"><a href="#cb17-90" aria-hidden="true" tabindex="-1"></a>                code_in_binary <span class="op">=</span> code_in_binary.zfill(<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb17-91"><a href="#cb17-91" aria-hidden="true" tabindex="-1"></a>                encoding<span class="op">+=</span>code_in_binary</span>
<span id="cb17-92"><a href="#cb17-92" aria-hidden="true" tabindex="-1"></a>                I <span class="op">=</span> i</span>
<span id="cb17-93"><a href="#cb17-93" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-94"><a href="#cb17-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> I <span class="op">!=</span> <span class="st">""</span>:</span>
<span id="cb17-95"><a href="#cb17-95" aria-hidden="true" tabindex="-1"></a>            code_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__trie.search(I))[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb17-96"><a href="#cb17-96" aria-hidden="true" tabindex="-1"></a>            encoding<span class="op">+=</span>code_in_binary</span>
<span id="cb17-97"><a href="#cb17-97" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-98"><a href="#cb17-98" aria-hidden="true" tabindex="-1"></a>        end_time <span class="op">=</span> time.time()</span>
<span id="cb17-99"><a href="#cb17-99" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"time"</span>] <span class="op">=</span> end_time <span class="op">-</span> start_time</span>
<span id="cb17-100"><a href="#cb17-100" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"dict_size"</span>] <span class="op">=</span> <span class="va">self</span>.__codes_count</span>
<span id="cb17-101"><a href="#cb17-101" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"encoded_size"</span>] <span class="op">=</span> <span class="bu">len</span>(encoding)</span>
<span id="cb17-102"><a href="#cb17-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> encoding, <span class="va">self</span>.__stats</span>
<span id="cb17-103"><a href="#cb17-103" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-104"><a href="#cb17-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-105"><a href="#cb17-105" aria-hidden="true" tabindex="-1"></a><span class="fu">##### `decode`</span></span>
<span id="cb17-106"><a href="#cb17-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-107"><a href="#cb17-107" aria-hidden="true" tabindex="-1"></a>Realiza a decodificação. Cria uma árvore trie que busca copiar a árvore da codificação, porém nesse caso a árvore mapeia de código para sequencia original de bits.</span>
<span id="cb17-108"><a href="#cb17-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-109"><a href="#cb17-109" aria-hidden="true" tabindex="-1"></a><span class="fu">###### Funcionamento:</span></span>
<span id="cb17-110"><a href="#cb17-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-111"><a href="#cb17-111" aria-hidden="true" tabindex="-1"></a>Considerando que o dicionário com os dois símbolos já foi construído. O algoritmo então consome códigos da string de entrada (codificação) em blocos do tamanho definido para os códigos. Ao ler um código, o algoritmo verifica se esse já foi inserido no dicionário. Caso tenha sido, o primeiro símbolo dessa string é concatenado a string anterior, o resultado é adicionado ao dicionário caso já não esteja (foi utilizado um dicionário auxiliar para verificar isso), e impresso na saída. Finalmente, a string anterior é atualizada com a string recuperado pelo código e o processo se repete. Caso o código não esteja no dicionário, a string é concatenada ao seu primeiro símbolo, o resultado é adicionado ao dicionário e concatenado na saída.</span>
<span id="cb17-112"><a href="#cb17-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-115"><a href="#cb17-115" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-116"><a href="#cb17-116" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> decode(<span class="va">self</span>):</span>
<span id="cb17-117"><a href="#cb17-117" aria-hidden="true" tabindex="-1"></a>        decoding <span class="op">=</span> <span class="st">""</span></span>
<span id="cb17-118"><a href="#cb17-118" aria-hidden="true" tabindex="-1"></a>        previous_str <span class="op">=</span> <span class="st">""</span></span>
<span id="cb17-119"><a href="#cb17-119" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-120"><a href="#cb17-120" aria-hidden="true" tabindex="-1"></a>        it <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-121"><a href="#cb17-121" aria-hidden="true" tabindex="-1"></a>        decompressing_acumulator <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-122"><a href="#cb17-122" aria-hidden="true" tabindex="-1"></a>        start_time <span class="op">=</span> time.time()</span>
<span id="cb17-123"><a href="#cb17-123" aria-hidden="true" tabindex="-1"></a>        insertions <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb17-124"><a href="#cb17-124" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> idx <span class="op">&lt;</span> <span class="bu">len</span>(<span class="va">self</span>.__encoding):</span>
<span id="cb17-125"><a href="#cb17-125" aria-hidden="true" tabindex="-1"></a>            <span class="co"># used to calculate the decompressing rate </span></span>
<span id="cb17-126"><a href="#cb17-126" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(<span class="va">self</span>.__stats <span class="op">!=</span> <span class="va">None</span> <span class="kw">and</span> it <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> it <span class="op">%</span> <span class="dv">50</span> <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb17-127"><a href="#cb17-127" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__stats[<span class="st">"decompression_rates"</span>].append(decompressing_acumulator<span class="op">/</span><span class="dv">50</span>)</span>
<span id="cb17-128"><a href="#cb17-128" aria-hidden="true" tabindex="-1"></a>                decompressing_acumulator <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-129"><a href="#cb17-129" aria-hidden="true" tabindex="-1"></a>            actual_code <span class="op">=</span> <span class="va">self</span>.__encoding[idx : idx<span class="op">+</span><span class="va">self</span>.__code_size]</span>
<span id="cb17-130"><a href="#cb17-130" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> idx <span class="op">==</span> <span class="dv">0</span>: <span class="co"># trata especialmente o primeiro codigo</span></span>
<span id="cb17-131"><a href="#cb17-131" aria-hidden="true" tabindex="-1"></a>                previous_str <span class="op">=</span> <span class="va">self</span>.__table.search(actual_code)</span>
<span id="cb17-132"><a href="#cb17-132" aria-hidden="true" tabindex="-1"></a>                idx <span class="op">+=</span> <span class="va">self</span>.__code_size</span>
<span id="cb17-133"><a href="#cb17-133" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb17-134"><a href="#cb17-134" aria-hidden="true" tabindex="-1"></a>            insertions <span class="op">+=</span> <span class="dv">2</span></span>
<span id="cb17-135"><a href="#cb17-135" aria-hidden="true" tabindex="-1"></a>            <span class="co"># busca o codigo no dicionario</span></span>
<span id="cb17-136"><a href="#cb17-136" aria-hidden="true" tabindex="-1"></a>            actual_str <span class="op">=</span> <span class="va">self</span>.__table.search(actual_code) </span>
<span id="cb17-137"><a href="#cb17-137" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (actual_str <span class="op">!=</span> <span class="va">None</span>):<span class="co"># codigo na tabela</span></span>
<span id="cb17-138"><a href="#cb17-138" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="va">self</span>.__inserted_strs.search(previous_str <span class="op">+</span> actual_str[<span class="dv">0</span>]) <span class="op">==</span> <span class="va">None</span>:</span>
<span id="cb17-139"><a href="#cb17-139" aria-hidden="true" tabindex="-1"></a>                    code_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__code_count)[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__code_size)</span>
<span id="cb17-140"><a href="#cb17-140" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__table.insert(code_in_binary, previous_str <span class="op">+</span> actual_str[<span class="dv">0</span>])</span>
<span id="cb17-141"><a href="#cb17-141" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># dicionario auxiliar que possui como chave as sequencias inseridas</span></span>
<span id="cb17-142"><a href="#cb17-142" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__inserted_strs.insert(previous_str <span class="op">+</span> actual_str[<span class="dv">0</span>],<span class="dv">0</span>)</span>
<span id="cb17-143"><a href="#cb17-143" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__code_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-144"><a href="#cb17-144" aria-hidden="true" tabindex="-1"></a>                decoding <span class="op">+=</span> previous_str</span>
<span id="cb17-145"><a href="#cb17-145" aria-hidden="true" tabindex="-1"></a>                decompressing_acumulator <span class="op">+=</span> <span class="bu">len</span>(previous_str)</span>
<span id="cb17-146"><a href="#cb17-146" aria-hidden="true" tabindex="-1"></a>                previous_str <span class="op">=</span> actual_str</span>
<span id="cb17-147"><a href="#cb17-147" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb17-148"><a href="#cb17-148" aria-hidden="true" tabindex="-1"></a>                code_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__code_count)[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__code_size)</span>
<span id="cb17-149"><a href="#cb17-149" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__table.insert(code_in_binary,previous_str <span class="op">+</span> previous_str[<span class="dv">0</span>])</span>
<span id="cb17-150"><a href="#cb17-150" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__inserted_strs.insert(previous_str <span class="op">+</span> previous_str[<span class="dv">0</span>],<span class="dv">0</span>)</span>
<span id="cb17-151"><a href="#cb17-151" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__code_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-152"><a href="#cb17-152" aria-hidden="true" tabindex="-1"></a>                decoding <span class="op">+=</span> previous_str</span>
<span id="cb17-153"><a href="#cb17-153" aria-hidden="true" tabindex="-1"></a>                decompressing_acumulator <span class="op">+=</span> <span class="bu">len</span>(previous_str)</span>
<span id="cb17-154"><a href="#cb17-154" aria-hidden="true" tabindex="-1"></a>                previous_str <span class="op">=</span> previous_str <span class="op">+</span> previous_str[<span class="dv">0</span>]</span>
<span id="cb17-155"><a href="#cb17-155" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-156"><a href="#cb17-156" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">+=</span> <span class="va">self</span>.__code_size</span>
<span id="cb17-157"><a href="#cb17-157" aria-hidden="true" tabindex="-1"></a>            it <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-158"><a href="#cb17-158" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-159"><a href="#cb17-159" aria-hidden="true" tabindex="-1"></a>        end_time <span class="op">=</span> time.time()</span>
<span id="cb17-160"><a href="#cb17-160" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"time"</span>] <span class="op">=</span> end_time <span class="op">-</span> start_time</span>
<span id="cb17-161"><a href="#cb17-161" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"dict_size"</span>] <span class="op">=</span> insertions                            </span>
<span id="cb17-162"><a href="#cb17-162" aria-hidden="true" tabindex="-1"></a>        decoding <span class="op">+=</span> previous_str    </span>
<span id="cb17-163"><a href="#cb17-163" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> decoding, <span class="va">self</span>.__stats</span>
<span id="cb17-164"><a href="#cb17-164" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-165"><a href="#cb17-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-166"><a href="#cb17-166" aria-hidden="true" tabindex="-1"></a><span class="fu">#### 2. Encoder com código de tamanho variável</span></span>
<span id="cb17-167"><a href="#cb17-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-168"><a href="#cb17-168" aria-hidden="true" tabindex="-1"></a>Esta implementação usa códigos com tamanho inicial definido por parâmetro (default = 12) e crescente conforme a necessidade por novos códigos. Quando o limite de códigos máximo com n bits é atingido (2^n), não são mais criados códigos e apenas aqueles previamente inseridos são utilizados.</span>
<span id="cb17-169"><a href="#cb17-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-170"><a href="#cb17-170" aria-hidden="true" tabindex="-1"></a><span class="fu">##### `encode`</span></span>
<span id="cb17-171"><a href="#cb17-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-172"><a href="#cb17-172" aria-hidden="true" tabindex="-1"></a>Realiza a codificação de forma semelhar à implementação fixa. No entanto, separa os códigos formados por apenas 1's para serem flags indicadoras da mudança de tamanho dos códigos.</span>
<span id="cb17-173"><a href="#cb17-173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-176"><a href="#cb17-176" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-177"><a href="#cb17-177" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> encode(<span class="va">self</span>):</span>
<span id="cb17-178"><a href="#cb17-178" aria-hidden="true" tabindex="-1"></a>        encoding <span class="op">=</span> <span class="st">""</span></span>
<span id="cb17-179"><a href="#cb17-179" aria-hidden="true" tabindex="-1"></a>        I <span class="op">=</span> <span class="st">""</span></span>
<span id="cb17-180"><a href="#cb17-180" aria-hidden="true" tabindex="-1"></a>        count_compressions <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-181"><a href="#cb17-181" aria-hidden="true" tabindex="-1"></a>        start_time <span class="op">=</span> time.time()</span>
<span id="cb17-182"><a href="#cb17-182" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> idx, i <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.__input):</span>
<span id="cb17-183"><a href="#cb17-183" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(<span class="va">self</span>.__stats <span class="op">!=</span> <span class="va">None</span> <span class="kw">and</span> idx <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> idx <span class="op">%</span> <span class="dv">80</span> <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb17-184"><a href="#cb17-184" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__stats[<span class="st">"compression_rates"</span>].append(count_compressions<span class="op">/</span><span class="dv">80</span>)</span>
<span id="cb17-185"><a href="#cb17-185" aria-hidden="true" tabindex="-1"></a>                count_compressions <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-186"><a href="#cb17-186" aria-hidden="true" tabindex="-1"></a>            max_code <span class="op">=</span> <span class="bu">pow</span>(<span class="dv">2</span>,<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb17-187"><a href="#cb17-187" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="va">self</span>.__trie.search(I<span class="op">+</span>i) <span class="op">!=</span> <span class="va">None</span>:</span>
<span id="cb17-188"><a href="#cb17-188" aria-hidden="true" tabindex="-1"></a>                I <span class="op">=</span> I <span class="op">+</span> i</span>
<span id="cb17-189"><a href="#cb17-189" aria-hidden="true" tabindex="-1"></a>                count_compressions <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-190"><a href="#cb17-190" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb17-191"><a href="#cb17-191" aria-hidden="true" tabindex="-1"></a>                estourou <span class="op">=</span> <span class="va">False</span></span>
<span id="cb17-192"><a href="#cb17-192" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="va">self</span>.__codes_count <span class="op">==</span> max_code<span class="op">-</span><span class="dv">1</span>: <span class="co"># estourei o numero de codigos</span></span>
<span id="cb17-193"><a href="#cb17-193" aria-hidden="true" tabindex="-1"></a>                    estourou <span class="op">=</span> <span class="va">True</span></span>
<span id="cb17-194"><a href="#cb17-194" aria-hidden="true" tabindex="-1"></a>                    Icode_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__trie.search(I))[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb17-195"><a href="#cb17-195" aria-hidden="true" tabindex="-1"></a>                    encoding<span class="op">+=</span>Icode_in_binary</span>
<span id="cb17-196"><a href="#cb17-196" aria-hidden="true" tabindex="-1"></a>                    ones <span class="op">=</span> <span class="bu">bin</span>(<span class="bu">pow</span>(<span class="dv">2</span>,<span class="va">self</span>.__codes_bit_size) <span class="op">-</span> <span class="dv">1</span>)[<span class="dv">2</span>:]</span>
<span id="cb17-197"><a href="#cb17-197" aria-hidden="true" tabindex="-1"></a>                    encoding <span class="op">+=</span> ones</span>
<span id="cb17-198"><a href="#cb17-198" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__codes_bit_size <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-199"><a href="#cb17-199" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__codes_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-200"><a href="#cb17-200" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__trie.insert(I<span class="op">+</span>i,<span class="va">self</span>.__codes_count)</span>
<span id="cb17-201"><a href="#cb17-201" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__codes_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-202"><a href="#cb17-202" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">not</span> estourou: <span class="co"># caso nao tenha estourado nessa iteracao</span></span>
<span id="cb17-203"><a href="#cb17-203" aria-hidden="true" tabindex="-1"></a>                    code <span class="op">=</span> <span class="va">self</span>.__trie.search(I)</span>
<span id="cb17-204"><a href="#cb17-204" aria-hidden="true" tabindex="-1"></a>                    code_in_binary <span class="op">=</span> <span class="bu">bin</span>(code)</span>
<span id="cb17-205"><a href="#cb17-205" aria-hidden="true" tabindex="-1"></a>                    code_in_binary <span class="op">=</span> code_in_binary[<span class="dv">2</span>:]</span>
<span id="cb17-206"><a href="#cb17-206" aria-hidden="true" tabindex="-1"></a>                    code_in_binary <span class="op">=</span> code_in_binary.zfill(<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb17-207"><a href="#cb17-207" aria-hidden="true" tabindex="-1"></a>                    encoding<span class="op">+=</span>code_in_binary</span>
<span id="cb17-208"><a href="#cb17-208" aria-hidden="true" tabindex="-1"></a>                I <span class="op">=</span> i</span>
<span id="cb17-209"><a href="#cb17-209" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-210"><a href="#cb17-210" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> I <span class="op">!=</span> <span class="st">""</span>:</span>
<span id="cb17-211"><a href="#cb17-211" aria-hidden="true" tabindex="-1"></a>            code_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__trie.search(I))[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__codes_bit_size)</span>
<span id="cb17-212"><a href="#cb17-212" aria-hidden="true" tabindex="-1"></a>            encoding<span class="op">+=</span>code_in_binary</span>
<span id="cb17-213"><a href="#cb17-213" aria-hidden="true" tabindex="-1"></a>        end_time <span class="op">=</span> time.time()</span>
<span id="cb17-214"><a href="#cb17-214" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"time"</span>] <span class="op">=</span> end_time <span class="op">-</span> start_time</span>
<span id="cb17-215"><a href="#cb17-215" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"dict_size"</span>] <span class="op">=</span> <span class="va">self</span>.__codes_count</span>
<span id="cb17-216"><a href="#cb17-216" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"encoded_size"</span>] <span class="op">=</span> <span class="bu">len</span>(encoding)</span>
<span id="cb17-217"><a href="#cb17-217" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> encoding, <span class="va">self</span>.__stats</span>
<span id="cb17-218"><a href="#cb17-218" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-219"><a href="#cb17-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-220"><a href="#cb17-220" aria-hidden="true" tabindex="-1"></a><span class="fu">##### `decode`</span></span>
<span id="cb17-221"><a href="#cb17-221" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-222"><a href="#cb17-222" aria-hidden="true" tabindex="-1"></a>Implementação semelhante à implementação fixa. No entanto, precisa tratar o caso de que o código passado é uma flag para a mudança de tamanho dos códigos.</span>
<span id="cb17-223"><a href="#cb17-223" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-226"><a href="#cb17-226" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-227"><a href="#cb17-227" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> decode(<span class="va">self</span>):</span>
<span id="cb17-228"><a href="#cb17-228" aria-hidden="true" tabindex="-1"></a>        decoding <span class="op">=</span> <span class="st">""</span></span>
<span id="cb17-229"><a href="#cb17-229" aria-hidden="true" tabindex="-1"></a>        previous_str <span class="op">=</span> <span class="st">""</span></span>
<span id="cb17-230"><a href="#cb17-230" aria-hidden="true" tabindex="-1"></a>        idx <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-231"><a href="#cb17-231" aria-hidden="true" tabindex="-1"></a>        it <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-232"><a href="#cb17-232" aria-hidden="true" tabindex="-1"></a>        decompressing_acumulator <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-233"><a href="#cb17-233" aria-hidden="true" tabindex="-1"></a>        start_time <span class="op">=</span> time.time()</span>
<span id="cb17-234"><a href="#cb17-234" aria-hidden="true" tabindex="-1"></a>        insertions <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb17-235"><a href="#cb17-235" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> idx <span class="op">&lt;</span> <span class="bu">len</span>(<span class="va">self</span>.__encoding):</span>
<span id="cb17-236"><a href="#cb17-236" aria-hidden="true" tabindex="-1"></a>            <span class="co"># decompression rate computation</span></span>
<span id="cb17-237"><a href="#cb17-237" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span>(<span class="va">self</span>.__stats <span class="op">!=</span> <span class="va">None</span> <span class="kw">and</span> it <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> it <span class="op">%</span> <span class="dv">50</span> <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb17-238"><a href="#cb17-238" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__stats[<span class="st">"decompression_rates"</span>].append(decompressing_acumulator<span class="op">/</span><span class="dv">50</span>)</span>
<span id="cb17-239"><a href="#cb17-239" aria-hidden="true" tabindex="-1"></a>                decompressing_acumulator <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-240"><a href="#cb17-240" aria-hidden="true" tabindex="-1"></a>            actual_code <span class="op">=</span> <span class="va">self</span>.__encoding[idx : idx<span class="op">+</span><span class="va">self</span>.__code_size]</span>
<span id="cb17-241"><a href="#cb17-241" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> idx <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb17-242"><a href="#cb17-242" aria-hidden="true" tabindex="-1"></a>                previous_str <span class="op">=</span> <span class="va">self</span>.__table.search(actual_code)</span>
<span id="cb17-243"><a href="#cb17-243" aria-hidden="true" tabindex="-1"></a>                idx <span class="op">+=</span> <span class="va">self</span>.__code_size</span>
<span id="cb17-244"><a href="#cb17-244" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb17-245"><a href="#cb17-245" aria-hidden="true" tabindex="-1"></a>            <span class="co">#flag atual</span></span>
<span id="cb17-246"><a href="#cb17-246" aria-hidden="true" tabindex="-1"></a>            flag <span class="op">=</span> <span class="bu">bin</span>(<span class="bu">pow</span>(<span class="dv">2</span>,<span class="va">self</span>.__code_size) <span class="op">-</span><span class="dv">1</span>)[<span class="dv">2</span>:]</span>
<span id="cb17-247"><a href="#cb17-247" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> actual_code <span class="op">==</span> flag:</span>
<span id="cb17-248"><a href="#cb17-248" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__table.reroot()</span>
<span id="cb17-249"><a href="#cb17-249" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__code_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-250"><a href="#cb17-250" aria-hidden="true" tabindex="-1"></a>                idx <span class="op">+=</span> <span class="va">self</span>.__code_size</span>
<span id="cb17-251"><a href="#cb17-251" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__code_size <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-252"><a href="#cb17-252" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb17-253"><a href="#cb17-253" aria-hidden="true" tabindex="-1"></a>            insertions <span class="op">+=</span> <span class="dv">2</span></span>
<span id="cb17-254"><a href="#cb17-254" aria-hidden="true" tabindex="-1"></a>            actual_str <span class="op">=</span> <span class="va">self</span>.__table.search(actual_code) </span>
<span id="cb17-255"><a href="#cb17-255" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (actual_str <span class="op">!=</span> <span class="va">None</span>):<span class="co"># codigo na tabela</span></span>
<span id="cb17-256"><a href="#cb17-256" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="va">self</span>.__inserted_strs.search(previous_str <span class="op">+</span> actual_str[<span class="dv">0</span>]) <span class="op">==</span> <span class="va">None</span>:</span>
<span id="cb17-257"><a href="#cb17-257" aria-hidden="true" tabindex="-1"></a>                    code_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__code_count)[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__code_size)</span>
<span id="cb17-258"><a href="#cb17-258" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__table.insert(code_in_binary, previous_str <span class="op">+</span> actual_str[<span class="dv">0</span>])</span>
<span id="cb17-259"><a href="#cb17-259" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__inserted_strs.insert(previous_str <span class="op">+</span> actual_str[<span class="dv">0</span>],<span class="dv">0</span>)</span>
<span id="cb17-260"><a href="#cb17-260" aria-hidden="true" tabindex="-1"></a>                    <span class="va">self</span>.__code_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-261"><a href="#cb17-261" aria-hidden="true" tabindex="-1"></a>                decoding <span class="op">+=</span> previous_str</span>
<span id="cb17-262"><a href="#cb17-262" aria-hidden="true" tabindex="-1"></a>                decompressing_acumulator <span class="op">+=</span> <span class="bu">len</span>(previous_str)</span>
<span id="cb17-263"><a href="#cb17-263" aria-hidden="true" tabindex="-1"></a>                previous_str <span class="op">=</span> actual_str</span>
<span id="cb17-264"><a href="#cb17-264" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb17-265"><a href="#cb17-265" aria-hidden="true" tabindex="-1"></a>                code_in_binary <span class="op">=</span> <span class="bu">bin</span>(<span class="va">self</span>.__code_count)[<span class="dv">2</span>:].zfill(<span class="va">self</span>.__code_size)</span>
<span id="cb17-266"><a href="#cb17-266" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__table.insert(code_in_binary,previous_str <span class="op">+</span> previous_str[<span class="dv">0</span>])</span>
<span id="cb17-267"><a href="#cb17-267" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__inserted_strs.insert(previous_str <span class="op">+</span> previous_str[<span class="dv">0</span>],<span class="dv">0</span>)</span>
<span id="cb17-268"><a href="#cb17-268" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.__code_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-269"><a href="#cb17-269" aria-hidden="true" tabindex="-1"></a>                decoding <span class="op">+=</span> previous_str</span>
<span id="cb17-270"><a href="#cb17-270" aria-hidden="true" tabindex="-1"></a>                decompressing_acumulator <span class="op">+=</span> <span class="bu">len</span>(previous_str)</span>
<span id="cb17-271"><a href="#cb17-271" aria-hidden="true" tabindex="-1"></a>                previous_str <span class="op">=</span> previous_str <span class="op">+</span> previous_str[<span class="dv">0</span>]</span>
<span id="cb17-272"><a href="#cb17-272" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-273"><a href="#cb17-273" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">+=</span> <span class="va">self</span>.__code_size</span>
<span id="cb17-274"><a href="#cb17-274" aria-hidden="true" tabindex="-1"></a>            it <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-275"><a href="#cb17-275" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-276"><a href="#cb17-276" aria-hidden="true" tabindex="-1"></a>        end_time <span class="op">=</span> time.time()</span>
<span id="cb17-277"><a href="#cb17-277" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"time"</span>] <span class="op">=</span> end_time <span class="op">-</span> start_time</span>
<span id="cb17-278"><a href="#cb17-278" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.__stats[<span class="st">"dict_size"</span>] <span class="op">=</span> insertions                   </span>
<span id="cb17-279"><a href="#cb17-279" aria-hidden="true" tabindex="-1"></a>        decoding <span class="op">+=</span> previous_str    </span>
<span id="cb17-280"><a href="#cb17-280" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> decoding, <span class="va">self</span>.__stats</span>
<span id="cb17-281"><a href="#cb17-281" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-282"><a href="#cb17-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-283"><a href="#cb17-283" aria-hidden="true" tabindex="-1"></a><span class="fu">### Dicionário</span></span>
<span id="cb17-284"><a href="#cb17-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-285"><a href="#cb17-285" aria-hidden="true" tabindex="-1"></a>Para a implementação do dicionário, utilizamos uma árvore de prefixos, em especial uma árvore trie compacta. Nesta árvore, as chaves de busca e inserção são os valores binários dos códigos ou do conteúdo dos arquivos, transformados em strings de 0s e 1s. Isso aumenta o custo em memória do algoritmo, que utiliza um caractere para cada bit da chave, mas facilita a implementação dos algoritmos que precisam manipular e comparar essas strings para verificar quando os prefixos casam.</span>
<span id="cb17-286"><a href="#cb17-286" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-287"><a href="#cb17-287" aria-hidden="true" tabindex="-1"></a>A trie implementada aqui trata a raiz como um nó cabeça, onde o prefixo armazenado é a string vazia. Contanto que os devidos cuidados sejam tomados ao manipular este nó, isso facilita a implementação dos métodos, visto que todos eles podem iniciar a partir dela seguramente, sabendo que a string vazia é um prefixo de todas as strings.</span>
<span id="cb17-288"><a href="#cb17-288" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-289"><a href="#cb17-289" aria-hidden="true" tabindex="-1"></a>A seguir, temos uma explicação dos métodos implementados na classe do Dicionário, incluindo os métodos auxiliares.</span>
<span id="cb17-290"><a href="#cb17-290" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-291"><a href="#cb17-291" aria-hidden="true" tabindex="-1"></a><span class="fu">#### `_prefix_match`</span></span>
<span id="cb17-292"><a href="#cb17-292" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-293"><a href="#cb17-293" aria-hidden="true" tabindex="-1"></a>Um método auxiliar <span class="in">`_prefix_match`</span> foi implementado para fazer as comparações entre diferentes strings: ele verifica qual é o maior prefixo em comum entre as duas strings passadas. Isso é útil na inserção, por exemplo, onde o método é utilizado para descobrir a partir de que ponto a chave a ser inserida diverge da chave já armazenada, e que porção destas deve ser passada para um nó filho.</span>
<span id="cb17-294"><a href="#cb17-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-297"><a href="#cb17-297" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-298"><a href="#cb17-298" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> _prefix_match(<span class="va">self</span>, s1: <span class="bu">str</span>, s2: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb17-299"><a href="#cb17-299" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Returns the length of the largest common prefix of s1 and s2"""</span></span>
<span id="cb17-300"><a href="#cb17-300" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-301"><a href="#cb17-301" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c1, c2 <span class="kw">in</span> <span class="bu">zip</span>(s1, s2):</span>
<span id="cb17-302"><a href="#cb17-302" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> c1 <span class="op">!=</span> c2:</span>
<span id="cb17-303"><a href="#cb17-303" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb17-304"><a href="#cb17-304" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-305"><a href="#cb17-305" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> i</span>
<span id="cb17-306"><a href="#cb17-306" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-307"><a href="#cb17-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-308"><a href="#cb17-308" aria-hidden="true" tabindex="-1"></a><span class="fu">#### `search`</span></span>
<span id="cb17-309"><a href="#cb17-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-310"><a href="#cb17-310" aria-hidden="true" tabindex="-1"></a>Este é o método que performa a busca na trie compacta. A partir da raiz, ele escolhe um dos filhos para buscar baseado no primeiro dígito da parte ainda não casada da chave que está sendo buscada. Ele então verifica se a chave casa todo o prefixo armazenado naquele nó, acumula o prefixo casado, e em seguida, repete o processo a partir deste nó filho, e assim sucessivamente até que a chave seja encontrada, a profundidade da trie seja exaurida, ou alguma divergência ocorra. Nesses últimos dois casos, a chave não está na trie.</span>
<span id="cb17-311"><a href="#cb17-311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-314"><a href="#cb17-314" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-315"><a href="#cb17-315" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> search(<span class="va">self</span>, bit_str: <span class="bu">str</span>):</span>
<span id="cb17-316"><a href="#cb17-316" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Searches a bit string in the dictionary and returns the value on success, or None if not found."""</span></span>
<span id="cb17-317"><a href="#cb17-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-318"><a href="#cb17-318" aria-hidden="true" tabindex="-1"></a>    node <span class="op">=</span> <span class="va">self</span>.root</span>
<span id="cb17-319"><a href="#cb17-319" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-320"><a href="#cb17-320" aria-hidden="true" tabindex="-1"></a>    length <span class="op">=</span> <span class="bu">len</span>(bit_str)</span>
<span id="cb17-321"><a href="#cb17-321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-322"><a href="#cb17-322" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> length:</span>
<span id="cb17-323"><a href="#cb17-323" aria-hidden="true" tabindex="-1"></a>        bit <span class="op">=</span> <span class="bu">int</span>(bit_str[i])</span>
<span id="cb17-324"><a href="#cb17-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-325"><a href="#cb17-325" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Search reached a leaf without fully matching bit_str</span></span>
<span id="cb17-326"><a href="#cb17-326" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node.children[bit] <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb17-327"><a href="#cb17-327" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb17-328"><a href="#cb17-328" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-329"><a href="#cb17-329" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Child diverges from bit_str -&gt; there can't be a leaf that matches bit_str fully</span></span>
<span id="cb17-330"><a href="#cb17-330" aria-hidden="true" tabindex="-1"></a>        child <span class="op">=</span> node.children[bit]</span>
<span id="cb17-331"><a href="#cb17-331" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> bit_str.startswith(child.prefix, i):</span>
<span id="cb17-332"><a href="#cb17-332" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb17-333"><a href="#cb17-333" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-334"><a href="#cb17-334" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> child</span>
<span id="cb17-335"><a href="#cb17-335" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="bu">len</span>(child.prefix)</span>
<span id="cb17-336"><a href="#cb17-336" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> node.value</span>
<span id="cb17-337"><a href="#cb17-337" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-338"><a href="#cb17-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-339"><a href="#cb17-339" aria-hidden="true" tabindex="-1"></a><span class="fu">#### `insert`</span></span>
<span id="cb17-340"><a href="#cb17-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-341"><a href="#cb17-341" aria-hidden="true" tabindex="-1"></a>Este método é responsável por inserir na trie novos nós com uma chave e um valor, e atualizar o valor já presente caso a chave sendo inserida seja uma chave já inserida anteriormente. </span>
<span id="cb17-342"><a href="#cb17-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-343"><a href="#cb17-343" aria-hidden="true" tabindex="-1"></a>A ideia é percorrer a trie, de forma similar ao método de busca, buscando o nó onde a chave deveria estar, se estivesse presente. Se ela estiver de fato presente na trie, atualiza o valor já armazenado. Se houver divergência em algum nó e o prefixo armazenado nele não casar completamente com a chave sendo inserida, um novo filho é criado neste nó com a parte da nova chave que não foi casada, remanejando a trie para que ela se mantenha em um estado válido.</span>
<span id="cb17-344"><a href="#cb17-344" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-347"><a href="#cb17-347" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-348"><a href="#cb17-348" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> insert(<span class="va">self</span>, bit_str: <span class="bu">str</span>, value: <span class="bu">any</span>):</span>
<span id="cb17-349"><a href="#cb17-349" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb17-350"><a href="#cb17-350" aria-hidden="true" tabindex="-1"></a><span class="co">    Inserts a new value, with bit_str as the key, and updates the value if it already exists.</span></span>
<span id="cb17-351"><a href="#cb17-351" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns False if the key was updated, or True if it was inserted fresh.</span></span>
<span id="cb17-352"><a href="#cb17-352" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb17-353"><a href="#cb17-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-354"><a href="#cb17-354" aria-hidden="true" tabindex="-1"></a>    node <span class="op">=</span> <span class="va">self</span>.root</span>
<span id="cb17-355"><a href="#cb17-355" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb17-356"><a href="#cb17-356" aria-hidden="true" tabindex="-1"></a>    length <span class="op">=</span> <span class="bu">len</span>(bit_str)</span>
<span id="cb17-357"><a href="#cb17-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-358"><a href="#cb17-358" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;</span> length:</span>
<span id="cb17-359"><a href="#cb17-359" aria-hidden="true" tabindex="-1"></a>        bit <span class="op">=</span> <span class="bu">int</span>(bit_str[i])</span>
<span id="cb17-360"><a href="#cb17-360" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node.children[bit] <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb17-361"><a href="#cb17-361" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Creates a new node with the rest of bit_str as the key</span></span>
<span id="cb17-362"><a href="#cb17-362" aria-hidden="true" tabindex="-1"></a>            new_node <span class="op">=</span> Node(bit_str[i:], value)</span>
<span id="cb17-363"><a href="#cb17-363" aria-hidden="true" tabindex="-1"></a>            node.children[bit] <span class="op">=</span> new_node</span>
<span id="cb17-364"><a href="#cb17-364" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb17-365"><a href="#cb17-365" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-366"><a href="#cb17-366" aria-hidden="true" tabindex="-1"></a>        child <span class="op">=</span> node.children[bit]</span>
<span id="cb17-367"><a href="#cb17-367" aria-hidden="true" tabindex="-1"></a>        common_prefix_length <span class="op">=</span> <span class="va">self</span>._prefix_match(child.prefix, bit_str[i:])</span>
<span id="cb17-368"><a href="#cb17-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-369"><a href="#cb17-369" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> common_prefix_length <span class="op">==</span> <span class="bu">len</span>(child.prefix):</span>
<span id="cb17-370"><a href="#cb17-370" aria-hidden="true" tabindex="-1"></a>            <span class="co"># The whole prefix matched -&gt; move to the apropriate child</span></span>
<span id="cb17-371"><a href="#cb17-371" aria-hidden="true" tabindex="-1"></a>            node <span class="op">=</span> child</span>
<span id="cb17-372"><a href="#cb17-372" aria-hidden="true" tabindex="-1"></a>            i <span class="op">+=</span> common_prefix_length</span>
<span id="cb17-373"><a href="#cb17-373" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb17-374"><a href="#cb17-374" aria-hidden="true" tabindex="-1"></a>            <span class="co"># The strings diverge at this node -&gt; separate into 2 subtrees</span></span>
<span id="cb17-375"><a href="#cb17-375" aria-hidden="true" tabindex="-1"></a>            new_prefix <span class="op">=</span> child.prefix[:common_prefix_length]</span>
<span id="cb17-376"><a href="#cb17-376" aria-hidden="true" tabindex="-1"></a>            existing_suffix <span class="op">=</span> child.prefix[common_prefix_length:]</span>
<span id="cb17-377"><a href="#cb17-377" aria-hidden="true" tabindex="-1"></a>            new_suffix <span class="op">=</span> bit_str[i <span class="op">+</span> common_prefix_length:]</span>
<span id="cb17-378"><a href="#cb17-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-379"><a href="#cb17-379" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create new intermediary node for common prefix</span></span>
<span id="cb17-380"><a href="#cb17-380" aria-hidden="true" tabindex="-1"></a>            new_node <span class="op">=</span> Node(new_prefix)</span>
<span id="cb17-381"><a href="#cb17-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-382"><a href="#cb17-382" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Transform old node and add it as child to the new node</span></span>
<span id="cb17-383"><a href="#cb17-383" aria-hidden="true" tabindex="-1"></a>            child.prefix <span class="op">=</span> existing_suffix</span>
<span id="cb17-384"><a href="#cb17-384" aria-hidden="true" tabindex="-1"></a>            existing_suffix_bit <span class="op">=</span> <span class="bu">int</span>(existing_suffix[<span class="dv">0</span>])</span>
<span id="cb17-385"><a href="#cb17-385" aria-hidden="true" tabindex="-1"></a>            new_node.children[existing_suffix_bit] <span class="op">=</span> child</span>
<span id="cb17-386"><a href="#cb17-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-387"><a href="#cb17-387" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Adds a leaf to the new node if there is a suffix left in bit_str</span></span>
<span id="cb17-388"><a href="#cb17-388" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="bu">len</span>(new_suffix) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb17-389"><a href="#cb17-389" aria-hidden="true" tabindex="-1"></a>                leaf_node <span class="op">=</span> Node(new_suffix, value)</span>
<span id="cb17-390"><a href="#cb17-390" aria-hidden="true" tabindex="-1"></a>                leaf_node_bit <span class="op">=</span> <span class="bu">int</span>(new_suffix[<span class="dv">0</span>])</span>
<span id="cb17-391"><a href="#cb17-391" aria-hidden="true" tabindex="-1"></a>                new_node.children[leaf_node_bit] <span class="op">=</span> leaf_node</span>
<span id="cb17-392"><a href="#cb17-392" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb17-393"><a href="#cb17-393" aria-hidden="true" tabindex="-1"></a>                new_node.value <span class="op">=</span> value</span>
<span id="cb17-394"><a href="#cb17-394" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb17-395"><a href="#cb17-395" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Adds new intermediary node to the tree </span></span>
<span id="cb17-396"><a href="#cb17-396" aria-hidden="true" tabindex="-1"></a>            node.children[bit] <span class="op">=</span> new_node</span>
<span id="cb17-397"><a href="#cb17-397" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb17-398"><a href="#cb17-398" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-399"><a href="#cb17-399" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The key already existed in the trie -&gt; update its value</span></span>
<span id="cb17-400"><a href="#cb17-400" aria-hidden="true" tabindex="-1"></a>    node.value <span class="op">=</span> value</span>
<span id="cb17-401"><a href="#cb17-401" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb17-402"><a href="#cb17-402" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-403"><a href="#cb17-403" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-404"><a href="#cb17-404" aria-hidden="true" tabindex="-1"></a><span class="fu">#### `remove`</span></span>
<span id="cb17-405"><a href="#cb17-405" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-406"><a href="#cb17-406" aria-hidden="true" tabindex="-1"></a>Este é o método responsável pela remoção de elementos da trie, a partir de uma chave dada, retornando para o programa se a remoção teve sucesso ou não. Ele utiliza um método interno auxiliar <span class="in">`_remove`</span> que, recursivamente, percorre a árvore, aumentando o nível de profundidade até encontrar o nó que precisa ser apagado, caso exista. Em seguida, ele propaga para cima se o nó deve ser apagado ou não, de forma que, caso um nó possa ser compactado ou fique vazio, seu nó pai é avisado e o processo de compactação é feito. Esse efeito de propagação continua até atingir um nó que não precise ser apagado, indicando que, dali para cima, a trie não precisa ser modificada.</span>
<span id="cb17-407"><a href="#cb17-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-408"><a href="#cb17-408" aria-hidden="true" tabindex="-1"></a>A recursão é necessária aqui porque os nós da árvore de prefixos não têm um ponteiro para o pai, então esse mecanismo é utilizado para que seja possível viajar na árvore no sentido inverso. Esse método recursivo é o que garante que a trie compacta permaneça compacta ao remover um elemento, e sem isso a árvore poderia ser deixada num estado inválido. </span>
<span id="cb17-409"><a href="#cb17-409" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-412"><a href="#cb17-412" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-413"><a href="#cb17-413" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> remove(<span class="va">self</span>, bit_str: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb17-414"><a href="#cb17-414" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb17-415"><a href="#cb17-415" aria-hidden="true" tabindex="-1"></a><span class="co">    Removes key from dictionary, returning True on success and False on failure</span></span>
<span id="cb17-416"><a href="#cb17-416" aria-hidden="true" tabindex="-1"></a><span class="co">    (ex. if the key isn't in the dictionary)</span></span>
<span id="cb17-417"><a href="#cb17-417" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb17-418"><a href="#cb17-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-419"><a href="#cb17-419" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _remove(node: Node, bit_str: <span class="bu">str</span>, depth: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">tuple</span>[<span class="bu">bool</span>, <span class="bu">bool</span>]:</span>
<span id="cb17-420"><a href="#cb17-420" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb17-421"><a href="#cb17-421" aria-hidden="true" tabindex="-1"></a><span class="co">        Recursive method for removing key.</span></span>
<span id="cb17-422"><a href="#cb17-422" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns a tuple (bool, bool) indicating if the removal was successful</span></span>
<span id="cb17-423"><a href="#cb17-423" aria-hidden="true" tabindex="-1"></a><span class="co">        and if the child can be removed, respectively.</span></span>
<span id="cb17-424"><a href="#cb17-424" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb17-425"><a href="#cb17-425" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Node doesn't exist</span></span>
<span id="cb17-426"><a href="#cb17-426" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb17-427"><a href="#cb17-427" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="va">False</span>, <span class="va">False</span>)</span>
<span id="cb17-428"><a href="#cb17-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-429"><a href="#cb17-429" aria-hidden="true" tabindex="-1"></a>        <span class="co"># When the corresponding node is found</span></span>
<span id="cb17-430"><a href="#cb17-430" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> depth <span class="op">==</span> <span class="bu">len</span>(bit_str):</span>
<span id="cb17-431"><a href="#cb17-431" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node.value <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb17-432"><a href="#cb17-432" aria-hidden="true" tabindex="-1"></a>                node.value <span class="op">=</span> <span class="va">None</span>  <span class="co"># Delete value</span></span>
<span id="cb17-433"><a href="#cb17-433" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (<span class="va">True</span>, node.is_leaf()) <span class="co"># Node is leaf -&gt; can be deleted</span></span>
<span id="cb17-434"><a href="#cb17-434" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb17-435"><a href="#cb17-435" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="va">True</span>, <span class="va">False</span>)</span>
<span id="cb17-436"><a href="#cb17-436" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-437"><a href="#cb17-437" aria-hidden="true" tabindex="-1"></a>        bit <span class="op">=</span> <span class="bu">int</span>(bit_str[depth])</span>
<span id="cb17-438"><a href="#cb17-438" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node.children[bit] <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb17-439"><a href="#cb17-439" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="va">False</span>, <span class="va">False</span>)  <span class="co"># String is not in trie</span></span>
<span id="cb17-440"><a href="#cb17-440" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-441"><a href="#cb17-441" aria-hidden="true" tabindex="-1"></a>        child <span class="op">=</span> node.children[bit]</span>
<span id="cb17-442"><a href="#cb17-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-443"><a href="#cb17-443" aria-hidden="true" tabindex="-1"></a>        common_prefix_length <span class="op">=</span> <span class="va">self</span>._prefix_match(child.prefix, bit_str[depth:])</span>
<span id="cb17-444"><a href="#cb17-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-445"><a href="#cb17-445" aria-hidden="true" tabindex="-1"></a>        <span class="co"># bit_str diverges from the prefix, so it can't be on the trie</span></span>
<span id="cb17-446"><a href="#cb17-446" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> common_prefix_length <span class="op">&lt;</span> <span class="bu">len</span>(child.prefix):</span>
<span id="cb17-447"><a href="#cb17-447" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="va">False</span>, <span class="va">False</span>)</span>
<span id="cb17-448"><a href="#cb17-448" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-449"><a href="#cb17-449" aria-hidden="true" tabindex="-1"></a>        success, can_remove_child <span class="op">=</span> _remove(child, bit_str, depth <span class="op">+</span> common_prefix_length)</span>
<span id="cb17-450"><a href="#cb17-450" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> can_remove_child:</span>
<span id="cb17-451"><a href="#cb17-451" aria-hidden="true" tabindex="-1"></a>            node.children[bit] <span class="op">=</span> <span class="va">None</span></span>
<span id="cb17-452"><a href="#cb17-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-453"><a href="#cb17-453" aria-hidden="true" tabindex="-1"></a>            <span class="co"># If node now became an empty leaf, it can be removed too</span></span>
<span id="cb17-454"><a href="#cb17-454" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node.is_leaf() <span class="kw">and</span> node.value <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb17-455"><a href="#cb17-455" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (success, <span class="va">True</span>)</span>
<span id="cb17-456"><a href="#cb17-456" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-457"><a href="#cb17-457" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Node is not root, is empty and stil has another child that can be compacted into it</span></span>
<span id="cb17-458"><a href="#cb17-458" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> node.prefix <span class="op">!=</span> <span class="st">''</span> <span class="kw">and</span> node.value <span class="kw">is</span> <span class="va">None</span> <span class="kw">and</span> node.children.count(<span class="va">None</span>) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb17-459"><a href="#cb17-459" aria-hidden="true" tabindex="-1"></a>                remaining_child <span class="op">=</span> node.children[<span class="dv">1</span> <span class="op">-</span> bit]</span>
<span id="cb17-460"><a href="#cb17-460" aria-hidden="true" tabindex="-1"></a>                node.prefix <span class="op">+=</span> remaining_child.prefix</span>
<span id="cb17-461"><a href="#cb17-461" aria-hidden="true" tabindex="-1"></a>                node.value <span class="op">=</span> remaining_child.value</span>
<span id="cb17-462"><a href="#cb17-462" aria-hidden="true" tabindex="-1"></a>                node.children <span class="op">=</span> remaining_child.children</span>
<span id="cb17-463"><a href="#cb17-463" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> (success, <span class="va">False</span>)</span>
<span id="cb17-464"><a href="#cb17-464" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-465"><a href="#cb17-465" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Child couldn't be removed. Assuming tree was valid before, it should remain valid.</span></span>
<span id="cb17-466"><a href="#cb17-466" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (success, <span class="va">False</span>)</span>
<span id="cb17-467"><a href="#cb17-467" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-468"><a href="#cb17-468" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Starts recursive removal from root</span></span>
<span id="cb17-469"><a href="#cb17-469" aria-hidden="true" tabindex="-1"></a>    success, _ <span class="op">=</span> _remove(<span class="va">self</span>.root, bit_str, <span class="dv">0</span>)</span>
<span id="cb17-470"><a href="#cb17-470" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> success</span>
<span id="cb17-471"><a href="#cb17-471" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-472"><a href="#cb17-472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-473"><a href="#cb17-473" aria-hidden="true" tabindex="-1"></a><span class="fu">#### `reroot`</span></span>
<span id="cb17-474"><a href="#cb17-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-475"><a href="#cb17-475" aria-hidden="true" tabindex="-1"></a>Essa função não implementa uma funcionalidade padrão de um dicionário, mas sim uma funcionalidade útil para o algoritmo LZW. O objetivo desta função é acrescentar um prefixo 0 a todas as chaves já armazenadas na árvore. Isto é útil ao implementar o LZW com tamanho de código variável, pois, quando os códigos precisam aumentar de tamanho, essa função aumenta o tamanho de todos os códigos antigos para que sejam compatíveis com os novos códigos.</span>
<span id="cb17-476"><a href="#cb17-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-477"><a href="#cb17-477" aria-hidden="true" tabindex="-1"></a>Para atingir esse objetivo, a função cria uma nova raiz, transforma a antiga raiz para que ela possua um prefixo de 0, e define esse nó transformado como filho da nova raiz, de forma que toda a trie anterior se torna uma subárvore com prefixo 0. Um cuidado é tomado caso a raiz tenha apenas um filho, para que a propriedade de compactação da trie seja mantida.</span>
<span id="cb17-478"><a href="#cb17-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-481"><a href="#cb17-481" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-482"><a href="#cb17-482" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reroot(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb17-483"><a href="#cb17-483" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb17-484"><a href="#cb17-484" aria-hidden="true" tabindex="-1"></a><span class="co">    Creates a new root for the underlying trie. If the trie is not empty,</span></span>
<span id="cb17-485"><a href="#cb17-485" aria-hidden="true" tabindex="-1"></a><span class="co">    places the old root as child to the new root, with prefix 0 and no value.</span></span>
<span id="cb17-486"><a href="#cb17-486" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns true if rerooting took place, and false if it didn't.</span></span>
<span id="cb17-487"><a href="#cb17-487" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb17-488"><a href="#cb17-488" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-489"><a href="#cb17-489" aria-hidden="true" tabindex="-1"></a>    num_children <span class="op">=</span> <span class="dv">2</span> <span class="op">-</span> <span class="va">self</span>.root.children.count(<span class="va">None</span>)</span>
<span id="cb17-490"><a href="#cb17-490" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-491"><a href="#cb17-491" aria-hidden="true" tabindex="-1"></a>    <span class="co"># No values to be rerooted</span></span>
<span id="cb17-492"><a href="#cb17-492" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> num_children <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb17-493"><a href="#cb17-493" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb17-494"><a href="#cb17-494" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-495"><a href="#cb17-495" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Root has a single child, that would be fused into the new 0 node, so we</span></span>
<span id="cb17-496"><a href="#cb17-496" aria-hidden="true" tabindex="-1"></a>    <span class="co"># can just modify the current only child</span></span>
<span id="cb17-497"><a href="#cb17-497" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="va">self</span>.root.children.count(<span class="va">None</span>) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb17-498"><a href="#cb17-498" aria-hidden="true" tabindex="-1"></a>        bit <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> <span class="va">self</span>.root.children.index(<span class="va">None</span>)</span>
<span id="cb17-499"><a href="#cb17-499" aria-hidden="true" tabindex="-1"></a>        child <span class="op">=</span> <span class="va">self</span>.root.children[bit]</span>
<span id="cb17-500"><a href="#cb17-500" aria-hidden="true" tabindex="-1"></a>        child.prefix <span class="op">=</span> <span class="st">'0'</span> <span class="op">+</span> child.prefix</span>
<span id="cb17-501"><a href="#cb17-501" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.root.children <span class="op">=</span> [child, <span class="va">None</span>]</span>
<span id="cb17-502"><a href="#cb17-502" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb17-503"><a href="#cb17-503" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-504"><a href="#cb17-504" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Root has two children, transform it into the new 0 node and attach to new root</span></span>
<span id="cb17-505"><a href="#cb17-505" aria-hidden="true" tabindex="-1"></a>    old_root <span class="op">=</span> <span class="va">self</span>.root</span>
<span id="cb17-506"><a href="#cb17-506" aria-hidden="true" tabindex="-1"></a>    new_root <span class="op">=</span> Node(<span class="st">''</span>, <span class="va">None</span>)</span>
<span id="cb17-507"><a href="#cb17-507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-508"><a href="#cb17-508" aria-hidden="true" tabindex="-1"></a>    old_root.prefix <span class="op">=</span> <span class="st">'0'</span></span>
<span id="cb17-509"><a href="#cb17-509" aria-hidden="true" tabindex="-1"></a>    new_root.children[<span class="dv">0</span>] <span class="op">=</span> old_root</span>
<span id="cb17-510"><a href="#cb17-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-511"><a href="#cb17-511" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.root <span class="op">=</span> new_root</span>
<span id="cb17-512"><a href="#cb17-512" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb17-513"><a href="#cb17-513" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-514"><a href="#cb17-514" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-515"><a href="#cb17-515" aria-hidden="true" tabindex="-1"></a><span class="fu">## Análise</span></span>
<span id="cb17-516"><a href="#cb17-516" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-519"><a href="#cb17-519" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-520"><a href="#cb17-520" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb17-521"><a href="#cb17-521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-522"><a href="#cb17-522" aria-hidden="true" tabindex="-1"></a><span class="co"># Definições gerais</span></span>
<span id="cb17-523"><a href="#cb17-523" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb17-524"><a href="#cb17-524" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> json</span>
<span id="cb17-525"><a href="#cb17-525" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> os <span class="im">import</span> path</span>
<span id="cb17-526"><a href="#cb17-526" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-527"><a href="#cb17-527" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sanitize(filepath):</span>
<span id="cb17-528"><a href="#cb17-528" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> path.realpath(path.expanduser(filepath))</span>
<span id="cb17-529"><a href="#cb17-529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-530"><a href="#cb17-530" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_list(y,y_label,x_label,title):</span>
<span id="cb17-531"><a href="#cb17-531" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">len</span>(y)))</span>
<span id="cb17-532"><a href="#cb17-532" aria-hidden="true" tabindex="-1"></a>    plt.clf()</span>
<span id="cb17-533"><a href="#cb17-533" aria-hidden="true" tabindex="-1"></a>    plt.plot(x, y)</span>
<span id="cb17-534"><a href="#cb17-534" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-535"><a href="#cb17-535" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(x_label)</span>
<span id="cb17-536"><a href="#cb17-536" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(y_label)</span>
<span id="cb17-537"><a href="#cb17-537" aria-hidden="true" tabindex="-1"></a>    plt.title(title)</span>
<span id="cb17-538"><a href="#cb17-538" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-539"><a href="#cb17-539" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb17-540"><a href="#cb17-540" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-541"><a href="#cb17-541" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-542"><a href="#cb17-542" aria-hidden="true" tabindex="-1"></a>Para poder analisar o bom funcionamento do programa, foram feitos diversos testes, executando o programa com parâmetros diferentes e formatos de arquivo diferentes. Dessas execuções extraímos diversas métricas, como a taxa de compressão (e de descompressão) do arquivo ao longo da execução do programa, o tempo total de execução e a quantidade de inserções na trie. Utilizaremos essas métricas para caracterizar o programa.</span>
<span id="cb17-543"><a href="#cb17-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-544"><a href="#cb17-544" aria-hidden="true" tabindex="-1"></a>Um cuidado especial tomado foi o de testar o programa com formatos de arquivo descomprimidos, como imagens em formato Bitmap (.bmp) e arquivos de texto puros (.txt). Isso é necessário porque existe um limite para quanto uma informação pode ser comprimida, relacionado à <span class="co">[</span><span class="ot">entropia da informação definida por Shannon</span><span class="co">](https://pt.wikipedia.org/wiki/Entropia_da_informa%C3%A7%C3%A3o)</span>. Por esse motivo, arquivos já comprimidos anteriormente, como imagens .png e documentos .pdf tendem a não reduzir significativamente em tamanho com passagens adicionais por um algoritmo de compressão, o que faz com que esses formatos não sejam ideais para testar o funcionamento&nbsp;do&nbsp;programa.</span>
<span id="cb17-545"><a href="#cb17-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-546"><a href="#cb17-546" aria-hidden="true" tabindex="-1"></a>Nos arquivos de texto, foram feitos com três tamanhos diferentes de arquivo:</span>
<span id="cb17-547"><a href="#cb17-547" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-548"><a href="#cb17-548" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>um arquivo pequeno (6,25KB)</span>
<span id="cb17-549"><a href="#cb17-549" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>um arquivo médio (22,6KB) </span>
<span id="cb17-550"><a href="#cb17-550" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>e um arquivo grande (418KB).</span>
<span id="cb17-551"><a href="#cb17-551" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-552"><a href="#cb17-552" aria-hidden="true" tabindex="-1"></a>A primeira métrica a analisar é a taxa de compressão: para encontrar esse valor, marcamos toda vez que um bit é omitido da saída por já estar representado em um código. Esse valor é amostrado a cada 80 iterações do algoritmo. Abaixo temos as taxas de compressão para os três arquivos, com largura fixa:</span>
<span id="cb17-553"><a href="#cb17-553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-556"><a href="#cb17-556" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-557"><a href="#cb17-557" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-ncol: 3</span></span>
<span id="cb17-558"><a href="#cb17-558" aria-hidden="true" tabindex="-1"></a><span class="co">#| column: page</span></span>
<span id="cb17-559"><a href="#cb17-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-560"><a href="#cb17-560" aria-hidden="true" tabindex="-1"></a>files <span class="op">=</span> [</span>
<span id="cb17-561"><a href="#cb17-561" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/theraven_stats_encoding_fixed.json"</span>,</span>
<span id="cb17-562"><a href="#cb17-562" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/frankesteinCh1-2_stats_encoding_fixed.json"</span>,</span>
<span id="cb17-563"><a href="#cb17-563" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/frankesteinfull_stats_encoding_fixed.json"</span>,</span>
<span id="cb17-564"><a href="#cb17-564" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb17-565"><a href="#cb17-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-566"><a href="#cb17-566" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, <span class="bu">file</span> <span class="kw">in</span> <span class="bu">enumerate</span>(files):</span>
<span id="cb17-567"><a href="#cb17-567" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(sanitize(<span class="bu">file</span>),<span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb17-568"><a href="#cb17-568" aria-hidden="true" tabindex="-1"></a>        stats_encoding <span class="op">=</span> json.load(f)</span>
<span id="cb17-569"><a href="#cb17-569" aria-hidden="true" tabindex="-1"></a>        plot_list(y <span class="op">=</span> stats_encoding[<span class="st">"compression_rates"</span>],</span>
<span id="cb17-570"><a href="#cb17-570" aria-hidden="true" tabindex="-1"></a>                        y_label <span class="op">=</span> <span class="st">"Taxa de compressão"</span>, x_label <span class="op">=</span> <span class="st">"Iterações (x80)"</span>,</span>
<span id="cb17-571"><a href="#cb17-571" aria-hidden="true" tabindex="-1"></a>                        title<span class="op">=</span><span class="ss">f"Análise da taxa de compressão - Arquivo </span><span class="sc">{</span>i <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb17-572"><a href="#cb17-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-573"><a href="#cb17-573" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-574"><a href="#cb17-574" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-575"><a href="#cb17-575" aria-hidden="true" tabindex="-1"></a>E também com largura variável:</span>
<span id="cb17-576"><a href="#cb17-576" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-579"><a href="#cb17-579" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-580"><a href="#cb17-580" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-ncol: 3</span></span>
<span id="cb17-581"><a href="#cb17-581" aria-hidden="true" tabindex="-1"></a><span class="co">#| column: page</span></span>
<span id="cb17-582"><a href="#cb17-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-583"><a href="#cb17-583" aria-hidden="true" tabindex="-1"></a>files <span class="op">=</span> [</span>
<span id="cb17-584"><a href="#cb17-584" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/theraven_stats_encoding_variable.json"</span>,</span>
<span id="cb17-585"><a href="#cb17-585" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/frankesteinCh1-2_stats_encoding_variable.json"</span>,</span>
<span id="cb17-586"><a href="#cb17-586" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/frankesteinfull_stats_encoding_variable.json"</span>,</span>
<span id="cb17-587"><a href="#cb17-587" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb17-588"><a href="#cb17-588" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-589"><a href="#cb17-589" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, <span class="bu">file</span> <span class="kw">in</span> <span class="bu">enumerate</span>(files):</span>
<span id="cb17-590"><a href="#cb17-590" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(sanitize(<span class="bu">file</span>),<span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb17-591"><a href="#cb17-591" aria-hidden="true" tabindex="-1"></a>        stats_encoding <span class="op">=</span> json.load(f)</span>
<span id="cb17-592"><a href="#cb17-592" aria-hidden="true" tabindex="-1"></a>        plot_list(y <span class="op">=</span> stats_encoding[<span class="st">"compression_rates"</span>],</span>
<span id="cb17-593"><a href="#cb17-593" aria-hidden="true" tabindex="-1"></a>                        y_label <span class="op">=</span> <span class="st">"Taxa de compressão"</span>, x_label <span class="op">=</span> <span class="st">"Iterações (x80)"</span>,</span>
<span id="cb17-594"><a href="#cb17-594" aria-hidden="true" tabindex="-1"></a>                        title<span class="op">=</span><span class="ss">f"Análise da taxa de compressão - Arquivo </span><span class="sc">{</span>i <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb17-595"><a href="#cb17-595" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-596"><a href="#cb17-596" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-597"><a href="#cb17-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-598"><a href="#cb17-598" aria-hidden="true" tabindex="-1"></a>Podemos perceber que os três arquivos conseguiram atingir uma taxa de compressão semelhante ao final, próximo dos 95%. Isso significa que esse valor provavelmente está próximo do limite, e que o algoritmo está funcionando bem.</span>
<span id="cb17-599"><a href="#cb17-599" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-600"><a href="#cb17-600" aria-hidden="true" tabindex="-1"></a>Podemos perceber também que os arquivos maiores apresentaram maior variação nos valores amostrados, com os gráficos sendo muito mais erráticos ao redor da curva aparente nos arquivos maiores, enquanto nos arquivos menores o gráfico é mais bem comportado. Outro fator que influencia esse comportamento é o número de iterações/amostras: o arquivo menor levou cerca de 52000 iterações (o valor no eixo X representa 50 iterações por unidade), ao passo que o arquivo maior levou cerca de 3.6M iterações.</span>
<span id="cb17-601"><a href="#cb17-601" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-602"><a href="#cb17-602" aria-hidden="true" tabindex="-1"></a>Outro ponto importante é o de que a taxa de compressão parece subir um pouco mais lentamente na compressão variável em comparação com a compressão fixa. Isso fica ainda mais evidente ao analisar a taxa de descompressão, que mede quantos bits foram decodificados a cada amostra (medida a cada 50 iterações). Abaixo temos as taxas de descompressão para o arquivos médio:</span>
<span id="cb17-603"><a href="#cb17-603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-606"><a href="#cb17-606" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-607"><a href="#cb17-607" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-ncol: 2</span></span>
<span id="cb17-608"><a href="#cb17-608" aria-hidden="true" tabindex="-1"></a><span class="co">#| column: page</span></span>
<span id="cb17-609"><a href="#cb17-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-610"><a href="#cb17-610" aria-hidden="true" tabindex="-1"></a>files <span class="op">=</span> [</span>
<span id="cb17-611"><a href="#cb17-611" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/frankesteinCh1-2_stats_decoding_fixed.json"</span>,</span>
<span id="cb17-612"><a href="#cb17-612" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/frankesteinCh1-2_stats_decoding_variable.json"</span>,</span>
<span id="cb17-613"><a href="#cb17-613" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb17-614"><a href="#cb17-614" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-615"><a href="#cb17-615" aria-hidden="true" tabindex="-1"></a>titles <span class="op">=</span> [</span>
<span id="cb17-616"><a href="#cb17-616" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Análise da taxa de descompressão - Largura Fixa"</span>,</span>
<span id="cb17-617"><a href="#cb17-617" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Análise da taxa de descompressão - Largura Variável"</span></span>
<span id="cb17-618"><a href="#cb17-618" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb17-619"><a href="#cb17-619" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-620"><a href="#cb17-620" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, <span class="bu">file</span> <span class="kw">in</span> <span class="bu">enumerate</span>(files):</span>
<span id="cb17-621"><a href="#cb17-621" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(sanitize(<span class="bu">file</span>),<span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb17-622"><a href="#cb17-622" aria-hidden="true" tabindex="-1"></a>        stats_decoding <span class="op">=</span> json.load(f)</span>
<span id="cb17-623"><a href="#cb17-623" aria-hidden="true" tabindex="-1"></a>        plot_list(y <span class="op">=</span> stats_decoding[<span class="st">"decompression_rates"</span>],</span>
<span id="cb17-624"><a href="#cb17-624" aria-hidden="true" tabindex="-1"></a>                        y_label <span class="op">=</span> <span class="st">"Taxa de descompressão"</span>, x_label <span class="op">=</span> <span class="st">"Iterações (x50)"</span>,</span>
<span id="cb17-625"><a href="#cb17-625" aria-hidden="true" tabindex="-1"></a>                        title<span class="op">=</span>titles[i])</span>
<span id="cb17-626"><a href="#cb17-626" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-627"><a href="#cb17-627" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-628"><a href="#cb17-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-629"><a href="#cb17-629" aria-hidden="true" tabindex="-1"></a>Quanto ao número de inserções na trie, em todos os casos a versão com código de largura variável teve um número de inserções maior, já que o código pode "crescer" quando necessário:</span>
<span id="cb17-630"><a href="#cb17-630" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-631"><a href="#cb17-631" aria-hidden="true" tabindex="-1"></a>|           | Fixa | Variável |</span>
<span id="cb17-632"><a href="#cb17-632" aria-hidden="true" tabindex="-1"></a>|-----------|------|----------|</span>
<span id="cb17-633"><a href="#cb17-633" aria-hidden="true" tabindex="-1"></a>| Arquivo 1 | 4096 | 4490     |</span>
<span id="cb17-634"><a href="#cb17-634" aria-hidden="true" tabindex="-1"></a>| Arquivo 2 | 4096 | 12756    |</span>
<span id="cb17-635"><a href="#cb17-635" aria-hidden="true" tabindex="-1"></a>| Arquivo 3 | 4096 | 146788   |</span>
<span id="cb17-636"><a href="#cb17-636" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-637"><a href="#cb17-637" aria-hidden="true" tabindex="-1"></a>O mesmo acontece com arquivos de imagem, que abordaremos em seguida.</span>
<span id="cb17-638"><a href="#cb17-638" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-639"><a href="#cb17-639" aria-hidden="true" tabindex="-1"></a>Nos arquivos de imagem, temos dois exemplos:</span>
<span id="cb17-640"><a href="#cb17-640" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-641"><a href="#cb17-641" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>um gradiente simples, de 400px x 400px (468KB)</span>
<span id="cb17-642"><a href="#cb17-642" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>uma imagem mais detalhada e fotorrealista, de tamanho 640px x 426px (798KB)</span>
<span id="cb17-643"><a href="#cb17-643" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-644"><a href="#cb17-644" aria-hidden="true" tabindex="-1"></a><span class="al">![Um gradiente simples.](validation_data/realistic_gradient_400x400.bmp)</span></span>
<span id="cb17-645"><a href="#cb17-645" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-646"><a href="#cb17-646" aria-hidden="true" tabindex="-1"></a><span class="al">![Uma paisagem fotorrealista.](validation_data/sample_640x426.bmp)</span></span>
<span id="cb17-647"><a href="#cb17-647" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-648"><a href="#cb17-648" aria-hidden="true" tabindex="-1"></a>Abaixo temos as taxas de compressão utilizando largura fixa:</span>
<span id="cb17-649"><a href="#cb17-649" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-652"><a href="#cb17-652" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-653"><a href="#cb17-653" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-ncol: 2</span></span>
<span id="cb17-654"><a href="#cb17-654" aria-hidden="true" tabindex="-1"></a><span class="co">#| column: page</span></span>
<span id="cb17-655"><a href="#cb17-655" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-656"><a href="#cb17-656" aria-hidden="true" tabindex="-1"></a>files <span class="op">=</span> [</span>
<span id="cb17-657"><a href="#cb17-657" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/realistic_gradient_400x400_stats_encoding_fixed.json"</span>,</span>
<span id="cb17-658"><a href="#cb17-658" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/sample_640x426_stats_encoding_fixed.json"</span>,</span>
<span id="cb17-659"><a href="#cb17-659" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb17-660"><a href="#cb17-660" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-661"><a href="#cb17-661" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, <span class="bu">file</span> <span class="kw">in</span> <span class="bu">enumerate</span>(files):</span>
<span id="cb17-662"><a href="#cb17-662" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(sanitize(<span class="bu">file</span>),<span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb17-663"><a href="#cb17-663" aria-hidden="true" tabindex="-1"></a>        stats_encoding <span class="op">=</span> json.load(f)</span>
<span id="cb17-664"><a href="#cb17-664" aria-hidden="true" tabindex="-1"></a>        plot_list(y <span class="op">=</span> stats_encoding[<span class="st">"compression_rates"</span>],</span>
<span id="cb17-665"><a href="#cb17-665" aria-hidden="true" tabindex="-1"></a>                        y_label <span class="op">=</span> <span class="st">"Taxa de compressão"</span>, x_label <span class="op">=</span> <span class="st">"Iterações (x80)"</span>,</span>
<span id="cb17-666"><a href="#cb17-666" aria-hidden="true" tabindex="-1"></a>                        title<span class="op">=</span><span class="ss">f"Análise da taxa de compressão - Arquivo </span><span class="sc">{</span>i <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb17-667"><a href="#cb17-667" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-668"><a href="#cb17-668" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-669"><a href="#cb17-669" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-670"><a href="#cb17-670" aria-hidden="true" tabindex="-1"></a>E também com a largura variável:</span>
<span id="cb17-671"><a href="#cb17-671" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-674"><a href="#cb17-674" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb17-675"><a href="#cb17-675" aria-hidden="true" tabindex="-1"></a><span class="co">#| layout-ncol: 2</span></span>
<span id="cb17-676"><a href="#cb17-676" aria-hidden="true" tabindex="-1"></a><span class="co">#| column: page</span></span>
<span id="cb17-677"><a href="#cb17-677" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-678"><a href="#cb17-678" aria-hidden="true" tabindex="-1"></a>files <span class="op">=</span> [</span>
<span id="cb17-679"><a href="#cb17-679" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/realistic_gradient_400x400_stats_encoding_variable.json"</span>,</span>
<span id="cb17-680"><a href="#cb17-680" aria-hidden="true" tabindex="-1"></a>    <span class="st">"validation_data/sample_640x426_stats_encoding_variable.json"</span>,</span>
<span id="cb17-681"><a href="#cb17-681" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb17-682"><a href="#cb17-682" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-683"><a href="#cb17-683" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, <span class="bu">file</span> <span class="kw">in</span> <span class="bu">enumerate</span>(files):</span>
<span id="cb17-684"><a href="#cb17-684" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(sanitize(<span class="bu">file</span>),<span class="st">"r"</span>) <span class="im">as</span> f:</span>
<span id="cb17-685"><a href="#cb17-685" aria-hidden="true" tabindex="-1"></a>        stats_encoding <span class="op">=</span> json.load(f)</span>
<span id="cb17-686"><a href="#cb17-686" aria-hidden="true" tabindex="-1"></a>        plot_list(y <span class="op">=</span> stats_encoding[<span class="st">"compression_rates"</span>],</span>
<span id="cb17-687"><a href="#cb17-687" aria-hidden="true" tabindex="-1"></a>                        y_label <span class="op">=</span> <span class="st">"Taxa de compressão"</span>, x_label <span class="op">=</span> <span class="st">"Iterações (x80)"</span>,</span>
<span id="cb17-688"><a href="#cb17-688" aria-hidden="true" tabindex="-1"></a>                        title<span class="op">=</span><span class="ss">f"Análise da taxa de compressão - Arquivo </span><span class="sc">{</span>i <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb17-689"><a href="#cb17-689" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-690"><a href="#cb17-690" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb17-691"><a href="#cb17-691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-692"><a href="#cb17-692" aria-hidden="true" tabindex="-1"></a>Imediatamente podemos ver que, assim como nos arquivos de texto maiores, a variabilidade da taxa de compressão também é grande. As imagens em formato bitmap tendem a ser grandes por não serem comprimidas, o que explica a variabilidade encontrada. Apesar disso, as curvas nas duas imagens se afinam ao final, chegando mais próximas de convergir a um valor fixo.</span>
<span id="cb17-693"><a href="#cb17-693" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-694"><a href="#cb17-694" aria-hidden="true" tabindex="-1"></a>Também é possível notar que a taxa de compressão foi menor na imagem realista do que no gradiente, apesar do tamanho. Isso se dá pela natureza do algoritmo LZW, que explora as repetições de padrões no texto para reduzir seu tamanho. Numa imagem mais simples, como um gradiente, há muita repetição, o que faz com que o algoritmo tenha mais oportunidades de compressão, em oposição à imagem fotorrealista, que por conter muitos detalhes diferentes, não tem muitos padrões que se repetem, o que não permite que o algoritmo seja tão eficiente. Sendo assim, podemos generalizar que o algoritmo funciona melhor em imagens com muita repetição de padrões e elementos.</span>
<span id="cb17-695"><a href="#cb17-695" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-696"><a href="#cb17-696" aria-hidden="true" tabindex="-1"></a>Pode-se perceber também que a compressão com tamanho de código variável chega mais perto do valor final gradualmente e crescendo, enquanto a versão com tamanho fixo chega a um valor máximo mas depois decai, oscilando até chegar no valor final.</span>
<span id="cb17-697"><a href="#cb17-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-698"><a href="#cb17-698" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusão</span></span>
<span id="cb17-699"><a href="#cb17-699" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-700"><a href="#cb17-700" aria-hidden="true" tabindex="-1"></a>O algoritmo LZW é um algoritmo de compressão baseado em dicionários que explora padrões repetidos no arquivo de entrada para reduzir o tamanho do arquivo final. Ele funciona melhor em arquivos de texto do que imagens, e funciona melhor em arquivos não-comprimidos que possuem muita repetição, como imagens mais simples, por exemplo.</span>
<span id="cb17-701"><a href="#cb17-701" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-702"><a href="#cb17-702" aria-hidden="true" tabindex="-1"></a>A trie compacta, apesar de ser uma escolha lógica para essa aplicação, não é a melhor escolha em sua forma padrão. Otimizações como a utilização de funções de hash podem fazer com que ela seja mais eficiente para o LZW em particular.</span>
</code><button title="Copiar para a área de transferência" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>